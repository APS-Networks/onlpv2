diff '--exclude=.git' -aruN ./OpenNetworkLinux/builds/amd64/installer/installed/builds/boot-config ../stordis_onlpv2/OpenNetworkLinux/builds/amd64/installer/installed/builds/boot-config
--- ./OpenNetworkLinux/builds/amd64/installer/installed/builds/boot-config	2020-06-19 08:08:14.567480599 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/builds/amd64/installer/installed/builds/boot-config	2020-06-19 08:07:40.595556186 +0200
@@ -1,3 +1,4 @@
 NETDEV=ma1
 BOOTMODE=INSTALLED
 SWI=images::latest
+NETAUTO=dhcp
diff '--exclude=.git' -aruN ./OpenNetworkLinux/builds/any/rootfs/jessie/common/all-base-packages.yml ../stordis_onlpv2/OpenNetworkLinux/builds/any/rootfs/jessie/common/all-base-packages.yml
--- ./OpenNetworkLinux/builds/any/rootfs/jessie/common/all-base-packages.yml	2020-06-19 08:08:44.067417081 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/builds/any/rootfs/jessie/common/all-base-packages.yml	2020-06-19 08:13:58.838836312 +0200
@@ -78,3 +78,39 @@
 - strace
 - sysstat
 - ipmitool
+- autoconf
+- libtool
+- libc6-dev
+- g++
+- git
+- libboost-dev
+- python-dev
+- flex
+- bison
+- libevent-dev
+- libboost-test-dev
+- libboost-thread-dev
+- libboost-system-dev
+- bridge-utils
+- python-pip
+- python-ply
+- ethtool
+- libssl-dev
+- libpcap-dev
+- libusb-1.0-0-dev
+- libcurl4-gnutls-dev
+- automake
+- python-crcmod
+- python-jsonschema
+- xz-utils
+- libbz2-dev
+- ca-certificates
+- ca-certificates-java
+- apt-transport-https
+- default-jdk
+- default-jre
+- default-jre-headless
+- unzip
+- zip
+- zlib1g-dev
+- libjudy-dev
diff '--exclude=.git' -aruN ./OpenNetworkLinux/builds/any/rootfs/jessie/common/amd64-base-packages.yml ../stordis_onlpv2/OpenNetworkLinux/builds/any/rootfs/jessie/common/amd64-base-packages.yml
--- ./OpenNetworkLinux/builds/any/rootfs/jessie/common/amd64-base-packages.yml	2020-06-19 08:08:44.067417081 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/builds/any/rootfs/jessie/common/amd64-base-packages.yml	2020-06-19 08:07:40.599556178 +0200
@@ -11,7 +11,9 @@
 - hw-management
 - sx-kernel
 - onl-kernel-3.16-lts-x86-64-all-modules
-- onl-kernel-4.9-lts-x86-64-all-modules
-- onl-kernel-4.14-lts-x86-64-all-modules
+- onl-kernel-3.16-lts-x86-64-all
+#- onl-kernel-4.9-lts-x86-64-all-modules
+#- onl-kernel-4.14-lts-x86-64-all-modules
+#- onl-kernel-4.14-lts-x86-64-all
 - efibootmgr
 - gdisk
diff '--exclude=.git' -aruN ./OpenNetworkLinux/builds/any/rootfs/stretch/common/all-base-packages.yml ../stordis_onlpv2/OpenNetworkLinux/builds/any/rootfs/stretch/common/all-base-packages.yml
--- ./OpenNetworkLinux/builds/any/rootfs/stretch/common/all-base-packages.yml	2020-06-19 08:08:44.067417081 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/builds/any/rootfs/stretch/common/all-base-packages.yml	2020-06-19 08:07:40.599556178 +0200
@@ -77,3 +77,50 @@
 - tcpdump
 - strace
 - sysstat
+- autoconf
+- libtool
+- libc6-dev
+- g++
+- git
+- libboost-dev
+- python-dev
+- flex
+- bison
+- libevent-dev
+- libboost-test-dev
+- libboost-thread-dev
+- bridge-utils
+- python-pip
+- python-ply
+- ethtool
+- libssl-dev
+- libpcap-dev
+- libusb-1.0-0-dev
+- libcurl4-gnutls-dev
+- automake
+- python-crcmod
+- python-jsonschema
+- xz-utils
+- libbz2-dev
+- python3
+- python3-pip
+- python3-dev
+- python3-crcmod
+- python3-jsonschema
+- python3-yaml
+- pkg-config
+- curl
+- unzip
+- python-ipaddr
+- python-pyparsing
+- doxygen
+- python-ply
+- python-simplejson
+- python-packaging
+- python-vcversioner
+- python-functools32
+- python-six
+- python-wheel
+- python-futures
+- python-enum34
+- python-coverage
diff '--exclude=.git' -aruN ./OpenNetworkLinux/builds/any/rootfs/stretch/common/amd64-base-packages.yml ../stordis_onlpv2/OpenNetworkLinux/builds/any/rootfs/stretch/common/amd64-base-packages.yml
--- ./OpenNetworkLinux/builds/any/rootfs/stretch/common/amd64-base-packages.yml	2020-06-19 08:08:44.067417081 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/builds/any/rootfs/stretch/common/amd64-base-packages.yml	2020-06-19 08:07:40.599556178 +0200
@@ -9,7 +9,8 @@
 - grub2
 - onl-upgrade
 - hw-management
-- onl-kernel-4.9-lts-x86-64-all-modules
+#- onl-kernel-4.9-lts-x86-64-all-modules
 - onl-kernel-4.14-lts-x86-64-all-modules
+- onl-kernel-4.14-lts-x86-64-all
 - efibootmgr
 - gdisk
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/base/amd64/upgrade/builds/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/base/amd64/upgrade/builds/Makefile
--- ./OpenNetworkLinux/packages/base/amd64/upgrade/builds/Makefile	2020-06-19 08:08:44.071417073 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/base/amd64/upgrade/builds/Makefile	2020-06-19 08:07:40.599556178 +0200
@@ -2,10 +2,8 @@
 
 # All amd64 kernels
 KERNELS := $(shell $(ONLPM) --find-file onl-kernel-3.16-lts-x86-64-all:amd64 kernel-3.16-lts-x86_64-all) \
-	   $(shell $(ONLPM) --find-file onl-kernel-4.9-lts-x86-64-all:amd64 kernel-4.9-lts-x86_64-all) \
 	   $(shell $(ONLPM) --find-file onl-kernel-4.14-lts-x86-64-all:amd64 kernel-4.14-lts-x86_64-all)
 
-
 # Loader initrd
 INITRD := $(shell $(ONLPM) --find-file onl-loader-initrd:amd64 onl-loader-initrd-amd64.cpio.gz)
 MANIFEST := $(shell $(ONLPM) --find-file onl-loader-initrd:amd64 manifest.json)
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/base/amd64/upgrade/PKG.yml ../stordis_onlpv2/OpenNetworkLinux/packages/base/amd64/upgrade/PKG.yml
--- ./OpenNetworkLinux/packages/base/amd64/upgrade/PKG.yml	2020-06-19 08:08:44.071417073 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/base/amd64/upgrade/PKG.yml	2020-06-19 08:07:40.599556178 +0200
@@ -1,7 +1,7 @@
 prerequisites:
     packages:
       - onl-kernel-3.16-lts-x86-64-all:amd64
-      - onl-kernel-4.9-lts-x86-64-all:amd64
+      #- onl-kernel-4.9-lts-x86-64-all:amd64
       - onl-kernel-4.14-lts-x86-64-all:amd64
       - onl-loader-initrd:amd64
 
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/base/any/kernels/3.16-lts/patches/driver-igb-version-5.3.54.patch ../stordis_onlpv2/OpenNetworkLinux/packages/base/any/kernels/3.16-lts/patches/driver-igb-version-5.3.54.patch
--- ./OpenNetworkLinux/packages/base/any/kernels/3.16-lts/patches/driver-igb-version-5.3.54.patch	2020-06-19 08:08:14.615480494 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/base/any/kernels/3.16-lts/patches/driver-igb-version-5.3.54.patch	2020-06-19 08:07:40.603556168 +0200
@@ -43286,7 +43286,7 @@
 +#endif
 +
 +#ifndef AX_RELEASE_CODE
-+#define AX_RELEASE_CODE 0
++#define AX_RELEASE_CODE AX_RELEASE_VERSION(3,0)
 +#endif
 +
 +#if (AX_RELEASE_CODE && AX_RELEASE_CODE == AX_RELEASE_VERSION(3,0))
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/base/any/onlp-snmpd/builds/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/base/any/onlp-snmpd/builds/Makefile
--- ./OpenNetworkLinux/packages/base/any/onlp-snmpd/builds/Makefile	2020-06-19 08:08:44.091417030 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/base/any/onlp-snmpd/builds/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -26,7 +26,7 @@
 
 LIBONLP := $(shell $(ONLPM) --find-file onlp:$(ARCH) libonlp.so)
 
-GLOBAL_LINK_LIBS += -lpthread $(LIBONLP)
+GLOBAL_LINK_LIBS += -lm -lpthread $(LIBONLP)
 GLOBAL_LINK_LIBS += -Wl,--unresolved-symbols=ignore-in-shared-libs
 
 .DEFAULT_GOAL := onlp-snmpd
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/vendor-config/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/vendor-config/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/vendor-config/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/vendor-config/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/vendor-config/PKG.yml ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/vendor-config/PKG.yml
--- ./OpenNetworkLinux/packages/platforms/stordis/vendor-config/PKG.yml	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/vendor-config/PKG.yml	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+!include $ONL_TEMPLATES/platform-config-vendor.yml VENDOR=stordis Vendor=Stordis
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/vendor-config/src/python/stordis/__init__.py ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/vendor-config/src/python/stordis/__init__.py
--- ./OpenNetworkLinux/packages/platforms/stordis/vendor-config/src/python/stordis/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/vendor-config/src/python/stordis/__init__.py	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1,7 @@
+#!/usr/bin/python
+
+from onl.platform.base import *
+
+class OnlPlatformStordis(OnlPlatformBase):
+    MANUFACTURER='Stordis'
+    PRIVATE_ENTERPRISE_NUMBER=70567
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/modules/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/modules/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/modules/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/modules/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/modules/PKG.yml ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/modules/PKG.yml
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/modules/PKG.yml	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/modules/PKG.yml	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+!include $ONL_TEMPLATES/no-platform-modules.yml VENDOR=stordis BASENAME=x86-64-stordis-bf2556x-1t ARCH=amd64
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/lib/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/lib/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/lib/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/lib/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1,27 @@
+############################################################
+# <bsn.cl fy=2014 v=onl>
+#
+#           Copyright 2014 BigSwitch Networks, Inc.
+#
+# Licensed under the Eclipse Public License, Version 1.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#        http://www.eclipse.org/legal/epl-v10.html
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+# either express or implied. See the License for the specific
+# language governing permissions and limitations under the
+# License.
+#
+# </bsn.cl>
+############################################################
+#
+#
+############################################################
+PLATFORM := x86-64-stordis-bf2556x-1t
+include $(ONL)/packages/base/any/onlp/builds/platform/libonlp-platform.mk
+GLOBAL_LINK_LIBS += -ldl -lz
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+include $(ONL)/packages/base/any/onlp/builds/platform/build.mk
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/onlps/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/onlps/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/onlps/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/onlps/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1,24 @@
+############################################################
+# <bsn.cl fy=2014 v=onl>
+#
+#           Copyright 2014 BigSwitch Networks, Inc.
+#
+# Licensed under the Eclipse Public License, Version 1.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#        http://www.eclipse.org/legal/epl-v10.html
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+# either express or implied. See the License for the specific
+# language governing permissions and limitations under the
+# License.
+#
+# </bsn.cl>
+############################################################
+PLATFORM := x86-64-stordis-bf2556x-1t
+include $(ONL)/packages/base/any/onlp/builds/platform/onlps.mk
+GLOBAL_LINK_LIBS += -ldl -lz
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1,10 @@
+############################################################
+#
+#
+#
+############################################################
+include $(ONL)/make/config.mk
+
+MODULE := x86_64_stordis_bf2556x_1t
+AUTOMODULE := x86_64_stordis_bf2556x_1t
+include $(BUILDER)/definemodule.mk
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/auto/make.mk ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/auto/make.mk
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/auto/make.mk	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/auto/make.mk	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1,10 @@
+###############################################################################
+#
+# x86_64_stordis_bf2556x_1t Autogeneration
+#
+###############################################################################
+
+x86_64_stordis_bf2556x_1t_AUTO_DEFS := module/auto/x86_64_stordis_bf2556x_1t.yml
+x86_64_stordis_bf2556x_1t_AUTO_DIRS := module/inc/x86_64_stordis_bf2556x_1t module/src
+include $(BUILDER)/auto.mk
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/auto/x86_64_stordis_bf2556x_1t.yml ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/auto/x86_64_stordis_bf2556x_1t.yml
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/auto/x86_64_stordis_bf2556x_1t.yml	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/auto/x86_64_stordis_bf2556x_1t.yml	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,55 @@
+###############################################################################
+#
+# x86_64_stordis_bf2556x_1t Autogeneration Definitions.
+#
+###############################################################################
+
+cdefs: &cdefs
+- X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_LOGGING:
+    doc: "Include or exclude logging."
+    default: 1
+- X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT:
+    doc: "Default enabled log options."
+    default: AIM_LOG_OPTIONS_DEFAULT
+- X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT:
+    doc: "Default enabled log bits."
+    default: AIM_LOG_BITS_DEFAULT
+- X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT:
+    doc: "Default enabled custom log bits."
+    default: 0
+- X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB:
+    doc: "Default all porting macros to use the C standard libraries."
+    default: 1
+- X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS:
+    doc: "Include standard library headers for stdlib porting macros."
+    default: X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB
+- X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI:
+    doc: "Include generic uCli support."
+    default: 0
+- X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_DEFAULT_FAN_DIRECTION:
+    doc: "Assume chassis fan direction is the same as the PSU fan direction."
+    default: 0
+- X86_64_STORDIS_BF2556X_1T_CONFIG_SFP_COUNT:
+    doc: "SFP port numbers."
+    default: 64
+- X86_64_STORDIS_BF2556X_1T_CONFIG_FAN_RPM_MAX:
+    doc: "Max fan speed."
+    default: 13000
+
+definitions:
+  cdefs:
+    X86_64_STORDIS_BF2556X_1T_CONFIG_HEADER:
+      defs: *cdefs
+      basename: x86_64_stordis_bf2556x_1t_config
+
+  portingmacro:
+    X86_64_STORDIS_BF2556X_1T:
+      macros:
+        - malloc
+        - free
+        - memset
+        - memcpy
+        - strncpy
+        - vsnprintf
+        - snprintf
+        - strlen
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,157 @@
+/**************************************************************************//**
+ *
+ * @file
+ * @brief x86_64_stordis_BF2556X_1T Configuration Header
+ *
+ * @addtogroup x86_64_stordis_BF2556X_1T-config
+ * @{
+ *
+ *****************************************************************************/
+#ifndef __X86_64_STORDIS_BF2556X_1T_CONFIG_H__
+#define __X86_64_STORDIS_BF2556X_1T_CONFIG_H__
+
+#ifdef GLOBAL_INCLUDE_CUSTOM_CONFIG
+#include <global_custom_config.h>
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_INCLUDE_CUSTOM_CONFIG
+#include <x86_64_stordis_bf2556x_1t_custom_config.h>
+#endif
+
+/* <auto.start.cdefs(X86_64_STORDIS_BF2556X_1T_CONFIG_HEADER).header> */
+#include <AIM/aim.h>
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_LOGGING
+ *
+ * Include or exclude logging. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_LOGGING
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_LOGGING 1
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT
+ *
+ * Default enabled log options. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT AIM_LOG_OPTIONS_DEFAULT
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT
+ *
+ * Default enabled log bits. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT AIM_LOG_BITS_DEFAULT
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT
+ *
+ * Default enabled custom log bits. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT 0
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB
+ *
+ * Default all porting macros to use the C standard libraries. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB 1
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS
+ *
+ * Include standard library headers for stdlib porting macros. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI
+ *
+ * Include generic uCli support. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI 0
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_DEFAULT_FAN_DIRECTION
+ *
+ * Assume chassis fan direction is the same as the PSU fan direction. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_DEFAULT_FAN_DIRECTION
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_DEFAULT_FAN_DIRECTION 0
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_SFP_COUNT
+ *
+ * SFP port numbers. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_SFP_COUNT
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_SFP_COUNT 64
+#endif
+
+/**
+ * X86_64_STORDIS_BF2556X_1T_CONFIG_FAN_RPM_MAX
+ *
+ * Max fan speed. */
+
+
+#ifndef X86_64_STORDIS_BF2556X_1T_CONFIG_FAN_RPM_MAX
+#define X86_64_STORDIS_BF2556X_1T_CONFIG_FAN_RPM_MAX 13000
+#endif
+
+
+
+/**
+ * All compile time options can be queried or displayed
+ */
+
+/** Configuration settings structure. */
+typedef struct x86_64_stordis_bf2556x_1t_config_settings_s {
+    /** name */
+    const char* name;
+    /** value */
+    const char* value;
+} x86_64_stordis_bf2556x_1t_config_settings_t;
+
+/** Configuration settings table. */
+/** x86_64_stordis_bf2556x_1t_config_settings table. */
+extern x86_64_stordis_bf2556x_1t_config_settings_t x86_64_stordis_bf2556x_1t_config_settings[];
+
+/**
+ * @brief Lookup a configuration setting.
+ * @param setting The name of the configuration option to lookup.
+ */
+const char* x86_64_stordis_bf2556x_1t_config_lookup(const char* setting);
+
+/**
+ * @brief Show the compile-time configuration.
+ * @param pvs The output stream.
+ */
+int x86_64_stordis_bf2556x_1t_config_show(struct aim_pvs_s* pvs);
+
+/* <auto.end.cdefs(X86_64_STORDIS_BF2556X_1T_CONFIG_HEADER).header> */
+
+#include "x86_64_stordis_bf2556x_1t_porting.h"
+
+#endif /* __X86_64_STORDIS_BF2556X_1T_CONFIG_H__ */
+/* @} */
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_dox.h ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_dox.h
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_dox.h	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_dox.h	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,26 @@
+/**************************************************************************//**
+ *
+ * x86_64_stordis_bf2556x_1t Doxygen Header
+ *
+ *****************************************************************************/
+#ifndef __X86_64_STORDIS_BF2556X_1T_DOX_H__
+#define _X86_64_STORDIS_BF2556X_1T_DOX_H__
+
+/**
+ * @defgroup x86_64_stordis_bf2556x_1t x86_64_stordis_bf2556x_1t - x86_64_stordis_bf2556x_1t Description
+ *
+
+The documentation overview for this module should go here.
+
+ *
+ * @{
+ *
+ * @defgroup x86_64_stordis_bf2556x_1t-x86_64_stordis_bf2556x_1t Public Interface
+ * @defgroup x86_64_stordis_bf2556x_1t-config Compile Time Configuration
+ * @defgroup x86_64_stordis_bf2556x_1t-porting Porting Macros
+ *
+ * @}
+ *
+ */
+
+#endif /* __X86_64_STORDIS_BF2556X_1T_DOX_H__ */
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_porting.h ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_porting.h
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_porting.h	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_porting.h	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,107 @@
+/**************************************************************************//**
+ *
+ * @file
+ * @brief x86_64_stordis_wb2448 Porting Macros.
+ *
+ * @addtogroup x86_64_stordis_wb2448-porting
+ * @{
+ *
+ *****************************************************************************/
+#ifndef __X86_64_STORDIS_BF2556X_1T_PORTING_H__
+#define __X86_64_STORDIS_BF2556X_1T_PORTING_H__
+
+
+/* <auto.start.portingmacro(ALL).define> */
+#if X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS == 1
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <memory.h>
+#endif
+
+#ifndef X86_64_STORDIS_BF2556X_1T_MALLOC
+    #if defined(GLOBAL_MALLOC)
+        #define X86_64_STORDIS_BF2556X_1T_MALLOC GLOBAL_MALLOC
+    #elif X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_STORDIS_BF2556X_1T_MALLOC malloc
+    #else
+        #error The macro X86_64_STORDIS_BF2556X_1T_MALLOC is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_STORDIS_BF2556X_1T_FREE
+    #if defined(GLOBAL_FREE)
+        #define X86_64_STORDIS_BF2556X_1T_FREE GLOBAL_FREE
+    #elif X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_STORDIS_BF2556X_1T_FREE free
+    #else
+        #error The macro X86_64_STORDIS_BF2556X_1T_FREE is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_STORDIS_BF2556X_1T_MEMSET
+    #if defined(GLOBAL_MEMSET)
+        #define X86_64_STORDIS_BF2556X_1T_MEMSET GLOBAL_MEMSET
+    #elif X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_STORDIS_BF2556X_1T_MEMSET memset
+    #else
+        #error The macro X86_64_STORDIS_BF2556X_1T_MEMSET is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_STORDIS_BF2556X_1T_MEMCPY
+    #if defined(GLOBAL_MEMCPY)
+        #define X86_64_STORDIS_BF2556X_1T_MEMCPY GLOBAL_MEMCPY
+    #elif X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_STORDIS_BF2556X_1T_MEMCPY memcpy
+    #else
+        #error The macro X86_64_STORDIS_BF2556X_1T_MEMCPY is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_STORDIS_BF2556X_1T_STRNCPY
+    #if defined(GLOBAL_STRNCPY)
+        #define X86_64_STORDIS_BF2556X_1T_STRNCPY GLOBAL_STRNCPY
+    #elif X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_STORDIS_BF2556X_1T_STRNCPY strncpy
+    #else
+        #error The macro X86_64_STORDIS_BF2556X_1T_STRNCPY is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_STORDIS_BF2556X_1T_VSNPRINTF
+    #if defined(GLOBAL_VSNPRINTF)
+        #define X86_64_STORDIS_BF2556X_1T_VSNPRINTF GLOBAL_VSNPRINTF
+    #elif X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_STORDIS_BF2556X_1T_VSNPRINTF vsnprintf
+    #else
+        #error The macro X86_64_STORDIS_BF2556X_1T_VSNPRINTF is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_STORDIS_BF2556X_1T_SNPRINTF
+    #if defined(GLOBAL_SNPRINTF)
+        #define X86_64_STORDIS_BF2556X_1T_SNPRINTF GLOBAL_SNPRINTF
+    #elif X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_STORDIS_BF2556X_1T_SNPRINTF snprintf
+    #else
+        #error The macro X86_64_STORDIS_BF2556X_1T_SNPRINTF is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_STORDIS_BF2556X_1T_STRLEN
+    #if defined(GLOBAL_STRLEN)
+        #define X86_64_STORDIS_BF2556X_1T_STRLEN GLOBAL_STRLEN
+    #elif X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_STORDIS_BF2556X_1T_STRLEN strlen
+    #else
+        #error The macro X86_64_STORDIS_BF2556X_1T_STRLEN is required but cannot be defined.
+    #endif
+#endif
+
+/* <auto.end.portingmacro(ALL).define> */
+
+
+#endif /* __X86_64_STORDIS_BF2556X_1T_PORTING_H__ */
+/* @} */
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t.x ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t.x
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t.x	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/inc/x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t.x	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,16 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+
+
+#include <x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h>
+
+/* <--auto.start.xmacro(ALL).define> */
+/* <auto.end.xmacro(ALL).define> */
+
+/* <--auto.start.xenum(ALL).define> */
+/* <auto.end.xenum(ALL).define> */
+
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/make.mk ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/make.mk
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/make.mk	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/make.mk	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,10 @@
+###############################################################################
+#
+#
+#
+###############################################################################
+THIS_DIR := $(dir $(lastword $(MAKEFILE_LIST)))
+x86_64_stordis_bf2556x_1t_INCLUDES := -I $(THIS_DIR)inc
+x86_64_stordis_bf2556x_1t_INTERNAL_INCLUDES := -I $(THIS_DIR)src
+x86_64_stordis_bf2556x_1t_DEPENDMODULE_ENTRIES := init:x86_64_stordis_bf2556x_1t ucli:x86_64_stordis_bf2556x_1t
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/attributei.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/attributei.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/attributei.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/attributei.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,73 @@
+#include <onlp/platformi/base.h>
+#include "vendor_driver_pool.h"
+#include "vendor_i2c_device_list.h"
+
+
+int
+onlp_attributei_onie_info_get(onlp_oid_t oid, onlp_onie_info_t* rp)
+{
+    int rv = -1;
+    int id = ONLP_OID_ID_GET(oid) - 1;
+    uint8_t data[256] = {0};
+    void *busDrv = (void *)vendor_find_driver_by_name(eeprom_dev_list[id].bus_drv_name);
+    eeprom_dev_driver_t *eeprom =
+        (eeprom_dev_driver_t *)vendor_find_driver_by_name(eeprom_dev_list[id].dev_drv_name);
+
+    if (!ONLP_OID_IS_TYPE(ONLP_OID_TYPE_CHASSIS, oid))
+    {
+        return ONLP_STATUS_E_UNSUPPORTED;
+    }
+
+    /* 
+     * Return OK when rp is a NULL pointer.
+     * Do not make sense, but just try to adapt onlp_attribute_onie_info_get().
+     */
+    if (rp == NULL)
+    {
+        return ONLP_STATUS_OK;
+    }
+
+    vendor_dev_do_oc(eeprom_o_list[id]);
+    if (eeprom_dev_list[id].id == 2)
+    {
+        rv = eeprom->load(
+            NULL,
+            eeprom_dev_list[id].bus,
+            eeprom_dev_list[id].addr,
+            data);
+    }
+    else
+    {
+        rv = eeprom->load(
+            busDrv,
+            eeprom_dev_list[id].bus,
+            eeprom_dev_list[id].addr,
+            data);
+    }
+    vendor_dev_do_oc(eeprom_c_list[id]);
+
+    rv = onlp_onie_decode(rp, data, 256);
+    if(rv < 0) return ONLP_STATUS_E_INVALID;
+
+    return ONLP_STATUS_OK;
+}
+
+int
+onlp_attributei_asset_info_get(onlp_oid_t oid, onlp_asset_info_t* rp)
+{
+    if (!ONLP_OID_IS_TYPE(ONLP_OID_TYPE_CHASSIS, oid))
+    {
+        return ONLP_STATUS_E_UNSUPPORTED;
+    }
+
+    /*
+     * Return OK when rp is a NULL pointer.
+     * Do not make sense, but just try to adapt onlp_attribute_asset_info_get().
+     */
+    if (rp == NULL)
+    {
+        return ONLP_STATUS_OK;
+    }
+
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/chassisi.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/chassisi.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/chassisi.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/chassisi.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,43 @@
+#include <onlp/platformi/chassisi.h>
+#include "vendor_i2c_device_list.h"
+
+
+int
+onlp_chassisi_hdr_get(onlp_oid_id_t id, onlp_oid_hdr_t* hdr)
+{
+    int i;
+    onlp_oid_t* e = hdr->coids;
+
+    memset(hdr->coids, 0, sizeof(hdr->coids));
+
+    ONLP_OID_STATUS_FLAG_SET(hdr, PRESENT);
+    ONLP_OID_STATUS_FLAG_SET(hdr, OPERATIONAL);
+
+    for (i = 1; i <= psu_list_size; i++)
+    {
+        *e++ = ONLP_PSU_ID_CREATE(i);
+    }
+
+    for (i = 1; i <= fan_list_size; i++)
+    {
+        *e++ = ONLP_FAN_ID_CREATE(i);
+    }
+    
+    for (i = 1; i <= thermal_list_size; i++)
+    {
+        *e++ = ONLP_THERMAL_ID_CREATE(i);
+    }
+
+    for(i = (1 + sfp_start_port); i <= (sfp_list_size + sfp_start_port); i++) 
+    {
+        *e++ = ONLP_SFP_ID_CREATE(i);
+    }
+
+    return 0;
+}
+
+int
+onlp_chassisi_info_get(onlp_oid_id_t id, onlp_chassis_info_t* info)
+{
+    return onlp_chassisi_hdr_get(id, &info->hdr);
+}
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/fani.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/fani.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/fani.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/fani.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,158 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *        Copyright 2014, 2015 Big Switch Networks, Inc.
+ *        Copyright 2017 Delta Networks, Inc.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ * Fan Platform Implementation Defaults.
+ *
+ ***********************************************************/
+#include <onlp/platformi/base.h>
+#include "vendor_driver_pool.h"
+#include "vendor_i2c_device_list.h"
+
+
+enum onlp_fan_id
+{
+    FAN_RESERVED = 0,
+    FAN_1_ON_FAN_BOARD,
+    FAN_2_ON_FAN_BOARD,
+    FAN_3_ON_FAN_BOARD,
+    FAN_4_ON_FAN_BOARD,
+    FAN_5_ON_FAN_BOARD,
+    FAN_6_ON_FAN_BOARD,
+    FAN_7_ON_FAN_BOARD,
+    FAN_8_ON_FAN_BOARD
+};
+
+#define FAN_INFO_ENTRY_INIT(_id, _desc)         \
+    {                                           \
+        {                                       \
+            .id = ONLP_FAN_ID_CREATE(_id),      \
+            .description = _desc,               \
+            .poid = 0,                          \
+            .status = 0,                        \
+        },                                      \
+        .caps = (ONLP_FAN_CAPS_GET_PERCENTAGE), \
+    }
+
+
+static onlp_fan_info_t onlp_fan_info[] = {
+    { }, /* Not used */
+    FAN_INFO_ENTRY_INIT(FAN_1_ON_FAN_BOARD, "FanPWM_0"),
+    FAN_INFO_ENTRY_INIT(FAN_2_ON_FAN_BOARD, "FanPWM_0_1"),
+    FAN_INFO_ENTRY_INIT(FAN_3_ON_FAN_BOARD, "FanPWM_1"),
+    FAN_INFO_ENTRY_INIT(FAN_4_ON_FAN_BOARD, "FanPWM_1_1"),
+    FAN_INFO_ENTRY_INIT(FAN_5_ON_FAN_BOARD, "FanPWM_2"),
+    FAN_INFO_ENTRY_INIT(FAN_6_ON_FAN_BOARD, "FanPWM_2_1"),
+    FAN_INFO_ENTRY_INIT(FAN_7_ON_FAN_BOARD, "FanPWM_3"),
+    FAN_INFO_ENTRY_INIT(FAN_8_ON_FAN_BOARD, "FanPWM_3_1"),
+};
+
+static int fan_max_rpm_list[] = {
+    23000,
+    20500,
+    23000,
+    20500,
+    23000,
+    20500,
+    23000,
+    20500
+};
+
+
+int onlp_fani_hdr_get(onlp_oid_t oid, onlp_oid_hdr_t* hdr)
+{
+    int rv = 0;
+    int id = ONLP_OID_ID_GET(oid) - 1;
+    int present = 0;
+
+    *hdr = onlp_fan_info[ONLP_OID_ID_GET(oid)].hdr;
+
+    rv = vendor_get_present_status(&fan_present_list[id], &present);
+    if(rv < 0) return ONLP_STATUS_E_INVALID;
+
+    if(present)
+    {
+        ONLP_OID_STATUS_FLAGS_CLR(hdr);
+        ONLP_OID_STATUS_FLAG_SET(hdr, PRESENT);
+    }
+    else
+    {
+        ONLP_OID_STATUS_FLAGS_CLR(hdr);
+        return ONLP_STATUS_OK;
+    }
+
+    return ONLP_STATUS_OK;
+}
+
+int onlp_fani_info_get(onlp_oid_t oid, onlp_fan_info_t* info)
+{
+    int rv = 0, fail = 0;
+    int id = ONLP_OID_ID_GET(oid) - 1;
+    onlp_oid_hdr_t *hdr;
+    void *busDrv = (void *)vendor_find_driver_by_name(fan_dev_list[id].bus_drv_name);
+    fan_dev_driver_t *fan = 
+        (fan_dev_driver_t *)vendor_find_driver_by_name(fan_dev_list[id].dev_drv_name);
+    int present = 0;
+    int rpm;
+
+    ONLP_OID_INFO_ASSIGN(ONLP_OID_ID_GET(oid), onlp_fan_info, info);
+    hdr = &info->hdr;
+
+    rv = vendor_get_present_status(&fan_present_list[id], &present);
+    if(rv < 0) return ONLP_STATUS_E_INVALID;
+
+    if(present)
+    {
+        ONLP_OID_STATUS_FLAGS_CLR(hdr);
+        ONLP_OID_STATUS_FLAG_SET(hdr, PRESENT);
+    }
+    else
+    {
+        ONLP_OID_STATUS_FLAGS_CLR(hdr);
+        return ONLP_STATUS_OK;
+    }
+
+    vendor_dev_do_oc(fan_o_list[id]);
+    if(fan->rpm_get(
+        busDrv, 
+        fan_dev_list[id].bus,
+        fan_dev_list[id].addr,
+        fan_dev_list[id].id, 
+        &rpm) != ONLP_STATUS_OK)
+    {
+        info->percentage = 0;
+        fail = 1;
+    }
+    vendor_dev_do_oc(fan_c_list[id]);
+
+    if(fail == 1) return ONLP_STATUS_E_INVALID;
+
+    info->percentage = (rpm * 100) / fan_max_rpm_list[id];
+    return ONLP_STATUS_OK;
+}
+
+int onlp_fani_rpm_set(onlp_oid_t oid, int rpm)
+{
+    if (oid || rpm) {}
+
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/ledi.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/ledi.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/ledi.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/ledi.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,141 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *           Copyright 2014 Big Switch Networks, Inc.
+ *           Copyright 2014 Accton Technology Corporation.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ *
+ *
+ ***********************************************************/
+#include <onlp/platformi/base.h>
+#include "vendor_driver_pool.h"
+#include "vendor_i2c_device_list.h"
+
+
+enum onlp_led_id
+{
+    LED_RESERVED = 0,
+    LED_SYS
+};
+
+#define LED_INFO_ENTRY_INIT(_id, _desc, _caps, _defaultm)      \
+    {                                               \
+        {                                           \
+            .id = ONLP_LED_ID_CREATE(_id),          \
+            .description = _desc,                   \
+            .poid = ONLP_OID_CHASSIS,               \
+            .status = ONLP_OID_STATUS_FLAG_PRESENT, \
+        },                                          \
+        .caps = _caps,                              \
+        .mode = _defaultm,                          \
+    }
+
+static onlp_led_info_t onlp_led_info[] =
+{
+    { }, /* Not used */
+    LED_INFO_ENTRY_INIT(LED_SYS, "sysled-system",
+        (ONLP_LED_CAPS_OFF | ONLP_LED_CAPS_RED | ONLP_LED_CAPS_GREEN | ONLP_LED_CAPS_GREEN_BLINKING ), ONLP_LED_MODE_GREEN)
+};
+
+int
+onlp_ledi_hdr_get(onlp_oid_t oid, onlp_oid_hdr_t* hdr)
+{
+    *hdr = onlp_led_info[ONLP_OID_ID_GET(oid)].hdr;
+    return ONLP_STATUS_OK;
+}
+
+int
+onlp_ledi_info_get(onlp_oid_t oid, onlp_led_info_t* info)
+{
+    //AIM_LOG_ERROR("Function: %s, instance: %d \n", __FUNCTION__, ONLP_OID_ID_GET(oid) - 1);
+    int rv = 0, id = ONLP_OID_ID_GET(oid) - 1, cpld_idx = 0;
+    vendor_dev_led_pin_t *curr_mode;
+    uint8_t mode = 0;
+    ONLP_OID_INFO_ASSIGN(ONLP_OID_ID_GET(oid), onlp_led_info, info);
+
+    void *busDrv = (void *)vendor_find_driver_by_name(sysled_dev_list[id].bus_drv_name);
+    cpld_dev_driver_t *cpld = 
+        (cpld_dev_driver_t *)vendor_find_driver_by_name(sysled_dev_list[id].dev_drv_name);
+
+    cpld_idx = vendor_find_cpld_idx(sysled_color_list[id]->addr);
+    if(cpld_idx < 0) return ONLP_STATUS_E_INTERNAL;
+
+    vendor_dev_do_oc(cpld_o_list[cpld_idx]);
+    rv = cpld->readb(
+        busDrv,
+        sysled_color_list[id]->bus,
+        sysled_color_list[id]->addr,
+        sysled_color_list[id]->offset,
+        &mode);
+    vendor_dev_do_oc(cpld_c_list[cpld_idx]);
+
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    curr_mode = sysled_color_list[id];
+
+    while (curr_mode->mode != ONLP_LED_MODE_INVALID)
+    {
+        if(((mode & curr_mode->mask) == curr_mode->match) ? 1 : 0)
+        {
+            info->mode = curr_mode->mode;
+            return ONLP_STATUS_OK;
+        }
+        curr_mode++;
+    }
+    
+    AIM_LOG_ERROR("Function: %s, Unknown LED mode.", __FUNCTION__);
+    return ONLP_STATUS_E_INTERNAL;
+}
+
+int
+onlp_ledi_mode_set(onlp_oid_t oid, onlp_led_mode_t mode)
+{
+    //AIM_LOG_ERROR("Function: %s, instance: %d \n", __FUNCTION__, ONLP_OID_ID_GET(oid) - 1);
+    int rv = 0, id = ONLP_OID_ID_GET(oid) - 1, cpld_idx = 0;
+    uint8_t curr_data = 0;
+
+    void *busDrv = (void *)vendor_find_driver_by_name(sysled_dev_list[id].bus_drv_name);
+    cpld_dev_driver_t *cpld = 
+        (cpld_dev_driver_t *)vendor_find_driver_by_name(sysled_dev_list[id].dev_drv_name);
+
+    cpld_idx = vendor_find_cpld_idx(sysled_color_list[id]->addr);
+    if(cpld_idx < 0) return ONLP_STATUS_E_INTERNAL;
+
+    vendor_dev_do_oc(cpld_o_list[cpld_idx]);
+    rv = cpld->readb(
+        busDrv,
+        sysled_color_list[id]->bus,
+        sysled_color_list[id]->addr,
+        sysled_color_list[id]->offset,
+        &curr_data);
+
+    curr_data &= ~sysled_color_list[id]->mask;
+    curr_data |= (sysled_color_list[id]->match & sysled_color_list[id]->mask);
+
+    rv = cpld->writeb(
+        busDrv,
+        sysled_color_list[id]->bus,
+        sysled_color_list[id]->addr,
+        sysled_color_list[id]->offset,
+        curr_data);
+    vendor_dev_do_oc(cpld_c_list[cpld_idx]);
+
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    
+    return ONLP_STATUS_OK;
+}
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/Makefile	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,9 @@
+###############################################################################
+#
+# Local source generation targets.
+#
+###############################################################################
+
+ucli:
+	$(SUBMODULE_BIGCODE)/tools/uclihandlers.py x86_64_stordis_bf2556x_1t_ucli.c
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/make.mk ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/make.mk
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/make.mk	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/make.mk	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,11 @@
+###############################################################################
+#
+# 
+#
+###############################################################################
+
+
+LIBRARY := x86_64_stordis_bf2556x_1t
+$(LIBRARY)_SUBDIR := $(dir $(lastword $(MAKEFILE_LIST)))
+#$(LIBRARY)_LAST := 1
+include $(BUILDER)/lib.mk
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/platformi.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/platformi.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/platformi.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/platformi.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,33 @@
+#include <onlp/platformi/base.h>
+#include "vendor_driver_pool.h"
+#include "vendor_i2c_device_list.h"
+
+#include "x86_64_stordis_bf2556x_1t_int.h"
+#include "x86_64_stordis_bf2556x_1t_log.h"
+
+
+const char*
+onlp_platformi_get(void)
+{
+    return "x86-64-stordis-bf2556x-1t-r0";
+}
+
+int
+onlp_platformi_sw_init(void)
+{
+    vendor_driver_init();
+
+    return 0;
+}
+
+int
+onlp_platformi_manage_fans(void)
+{
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
+
+int
+onlp_platformi_manage_leds(void)
+{
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/psui.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/psui.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/psui.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/psui.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,159 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *        Copyright 2014, 2015 Big Switch Networks, Inc.
+ *        Copyright 2017 Delta Networks, Inc.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ *
+ *
+ ***********************************************************/
+#include <onlp/platformi/base.h>
+#include "vendor_driver_pool.h"
+#include "vendor_i2c_device_list.h"
+
+
+enum onlp_psu_id
+{
+    PSU_RESERVED = 0,
+    PSU_1,
+    PSU_2
+};
+
+#define PSU_INFO_ENTRY_INIT(_id, _desc)    \
+    {                                      \
+        {                                  \
+            .id = ONLP_PSU_ID_CREATE(_id), \
+            .description = _desc,          \
+            .poid = ONLP_OID_CHASSIS,      \
+            .status = 0,                   \
+        },                                 \
+        .caps = (ONLP_PSU_CAPS_GET_TYPE | ONLP_PSU_CAPS_GET_VOUT | ONLP_PSU_CAPS_GET_POUT), \
+        .type = ONLP_PSU_TYPE_DC12, \
+    }
+
+
+static onlp_psu_info_t onlp_psu_info[] = {
+    { }, /* Not used */
+    PSU_INFO_ENTRY_INIT(PSU_1, "PSU 1"),
+    PSU_INFO_ENTRY_INIT(PSU_2, "PSU 2"),
+};
+
+
+int onlp_psui_hdr_get(onlp_oid_t oid, onlp_oid_hdr_t* hdr)
+{
+    int rv = 0;
+    int id = ONLP_OID_ID_GET(oid) - 1;
+    int present = 0;
+
+    *hdr = onlp_psu_info[ONLP_OID_ID_GET(oid)].hdr;
+
+    rv = vendor_get_present_status(&psu_present_list[id], &present);
+    if(rv < 0) return ONLP_STATUS_E_INVALID;
+
+    if(present)
+    {
+        ONLP_OID_STATUS_FLAGS_CLR(hdr);
+        ONLP_OID_STATUS_FLAG_SET(hdr, PRESENT);
+    }
+    else
+    {
+        ONLP_OID_STATUS_FLAGS_CLR(hdr);
+    }
+
+    return ONLP_STATUS_OK;
+}
+
+int onlp_psui_info_get(onlp_oid_t oid, onlp_psu_info_t* info)
+{
+    int rv = 0, fail = 0;
+    int id = ONLP_OID_ID_GET(oid) - 1;
+    onlp_oid_hdr_t *hdr;
+    void *busDrv = (void *)vendor_find_driver_by_name(psu_dev_list[id].bus_drv_name);
+    psu_dev_driver_t *psu = 
+        (psu_dev_driver_t *)vendor_find_driver_by_name(psu_dev_list[id].dev_drv_name);
+    int present = 0;
+    int mvout = 0, mpout = 0;
+
+    ONLP_OID_INFO_ASSIGN(ONLP_OID_ID_GET(oid), onlp_psu_info, info);
+    hdr = &info->hdr;
+
+    rv = vendor_get_present_status(&psu_present_list[id], &present);
+    if(rv < 0) return ONLP_STATUS_E_INVALID;
+
+    if(present)
+    {
+        ONLP_OID_STATUS_FLAGS_CLR(hdr);
+        ONLP_OID_STATUS_FLAG_SET(hdr, PRESENT);
+    }
+    else
+    {
+        ONLP_OID_STATUS_FLAGS_CLR(hdr);
+        return ONLP_STATUS_OK;
+    }
+
+    vendor_dev_do_oc(psu_o_list[id]);
+    if(psu->model_get(
+        busDrv, 
+        psu_dev_list[id].bus,
+        psu_dev_list[id].addr,
+        (char *) &info->model) != ONLP_STATUS_OK)
+    {
+        AIM_LOG_ERROR("psu->model_get failed.");
+        fail = 1;
+    }
+
+    if(psu->serial_get(
+        busDrv, 
+        psu_dev_list[id].bus,
+        psu_dev_list[id].addr,
+        (char *) &info->serial) != ONLP_STATUS_OK)
+    {
+        AIM_LOG_ERROR("psu->serial_get failed.");
+        fail = 1;
+    }
+
+    if(psu->volt_get(
+        busDrv, 
+        psu_dev_list[id].bus,
+        psu_dev_list[id].addr,
+        &mvout) != ONLP_STATUS_OK)
+    {
+        AIM_LOG_ERROR("psu->volt_get failed.");
+        fail = 1;
+    }
+
+    info->mvout = mvout;
+
+    if(psu->watt_get(
+        busDrv, 
+        psu_dev_list[id].bus,
+        psu_dev_list[id].addr,
+        &mpout) != ONLP_STATUS_OK)
+    {
+        AIM_LOG_ERROR("psu->watt_get failed.");
+        fail = 1;
+    }
+
+    info->mpout = mpout;
+    vendor_dev_do_oc(psu_o_list[id]);
+
+    if(fail == 1) return ONLP_STATUS_E_INVALID;
+
+    return ONLP_STATUS_OK;
+}
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/sfpi.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/sfpi.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/sfpi.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/sfpi.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,248 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *        Copyright 2014, 2015 Big Switch Networks, Inc.
+ *        Copyright 2017 Delta Networks, Inc.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ *
+ ***********************************************************/
+#include <onlp/platformi/base.h>
+#include "vendor_driver_pool.h"
+#include "vendor_i2c_device_list.h"
+
+
+int onlp_sfpi_bitmap_get(onlp_sfp_bitmap_t* bmap)
+{
+    int i;
+
+    AIM_BITMAP_CLR_ALL(bmap);
+
+    for (i = sfp_start_port; i < (sfp_list_size + sfp_start_port); i++)
+    {
+        AIM_BITMAP_SET(bmap, i);
+    }
+
+    return ONLP_STATUS_OK;
+}
+
+/*
+ * Return 1 if present.
+ * Return 0 if not present.
+ * Return < 0 if error.
+ */
+int onlp_sfpi_is_present(onlp_oid_id_t oid)
+{
+    int rv = 0;
+    int id = ONLP_OID_ID_GET(oid) - sfp_start_port;
+    int present = 0;
+
+    rv = vendor_get_present_status(&sfp_present_list[id], &present);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    return present;
+}
+
+int onlp_sfpi_presence_bitmap_get(onlp_sfp_bitmap_t* dst)
+{
+    int rv = 0;
+    int i;
+    int present = 0;
+
+    AIM_BITMAP_CLR_ALL(dst);
+
+    for (i = 0; i < sfp_list_size; i++)
+    {
+        rv = vendor_get_present_status(&sfp_present_list[i], &present);
+        if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+        if (present == 1)
+            AIM_BITMAP_SET(dst, (i+sfp_start_port+1));
+    }
+
+    return ONLP_STATUS_OK;
+}
+
+int
+onlp_sfpi_dev_read(onlp_oid_id_t oid, int devaddr, int addr,
+                   uint8_t* dst, int size)
+{
+    int rv = 0, fail = 0;
+    int id = ONLP_OID_ID_GET(oid) - sfp_start_port;
+    int present = 0;
+    uint8_t data[256] = {0};
+    int copy_size = sizeof(data);
+    void *busDrv = (void *)vendor_find_driver_by_name(sfp_dev_list[id].bus_drv_name);
+    sfp_dev_driver_t *sfp = 
+        (sfp_dev_driver_t *)vendor_find_driver_by_name(sfp_dev_list[id].dev_drv_name);
+
+    rv = vendor_get_present_status(&sfp_present_list[id], &present);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    if (present != 1)
+    {
+        return ONLP_STATUS_E_MISSING;
+    }
+
+    if (devaddr == 0x51)
+    {
+        if (id >= sfp_num_of_sfp)
+        {
+            return ONLP_STATUS_E_UNSUPPORTED;
+        }
+        else
+        {
+            vendor_dev_do_oc(sfp_o_list[id]);
+            if(sfp->eeprom_load(
+                busDrv, 
+                sfp_dev_list[id].bus,
+                0x51, 
+                data) != ONLP_STATUS_OK)
+            {
+                AIM_LOG_ERROR("sfp->eeprom_load failed.");
+                fail = 1;
+            }
+            vendor_dev_do_oc(sfp_c_list[id]);
+
+            if(fail == 1) return ONLP_STATUS_E_INTERNAL;
+        }
+    }
+    else
+    {
+        vendor_dev_do_oc(sfp_o_list[id]);
+        if(sfp->eeprom_load(
+            busDrv, 
+            sfp_dev_list[id].bus,
+            sfp_dev_list[id].addr, 
+            data) != ONLP_STATUS_OK)
+        {
+            AIM_LOG_ERROR("sfp->eeprom_load failed.");
+            fail = 1;
+        }
+        vendor_dev_do_oc(sfp_c_list[id]);
+
+        if(fail == 1) return ONLP_STATUS_E_INTERNAL;
+    }
+
+    copy_size -= addr;
+    if (copy_size > 0)
+    {
+        if (size > copy_size)
+            memcpy(dst, &data[addr], copy_size);
+        else
+            memcpy(dst, &data[addr], size);
+    }
+
+    return ONLP_STATUS_OK;
+}
+
+int
+onlp_sfpi_dev_readb(onlp_oid_id_t oid, int devaddr, int addr)
+{
+    int rv = 0, fail = 0;
+    int id = ONLP_OID_ID_GET(oid) - sfp_start_port;
+    int present = 0;
+    uint8_t data = 0;
+    void *busDrv = (void *)vendor_find_driver_by_name(sfp_dev_list[id].bus_drv_name);
+    sfp_dev_driver_t *sfp = 
+        (sfp_dev_driver_t *)vendor_find_driver_by_name(sfp_dev_list[id].dev_drv_name);
+
+    rv = vendor_get_present_status(&sfp_present_list[id], &present);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    if (present != 1)
+    {
+        return ONLP_STATUS_E_MISSING;
+    }
+
+    vendor_dev_do_oc(sfp_o_list[id]);
+    if(sfp->eeprom_readb(
+        busDrv, 
+        sfp_dev_list[id].bus,
+        sfp_dev_list[id].addr, 
+        addr,
+        &data) != ONLP_STATUS_OK)
+    {
+        AIM_LOG_ERROR("sfp->eeprom_readb failed.");
+        fail = 1;
+    }
+    vendor_dev_do_oc(sfp_c_list[id]);
+
+    if(fail == 1) return ONLP_STATUS_E_INTERNAL;
+
+    return (int)data;
+}
+
+int
+onlp_sfpi_dev_writeb(onlp_oid_id_t oid, int devaddr, int addr, uint8_t value)
+{
+    int rv = 0, fail = 0;
+    int id = ONLP_OID_ID_GET(oid) - sfp_start_port;
+    int present = 0;
+    void *busDrv = (void *)vendor_find_driver_by_name(sfp_dev_list[id].bus_drv_name);
+    sfp_dev_driver_t *sfp = 
+        (sfp_dev_driver_t *)vendor_find_driver_by_name(sfp_dev_list[id].dev_drv_name);
+
+    rv = vendor_get_present_status(&sfp_present_list[id], &present);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    if (present != 1)
+    {
+        return ONLP_STATUS_E_MISSING;
+    }
+
+    vendor_dev_do_oc(sfp_o_list[id]);
+    if(sfp->eeprom_writeb(
+        busDrv, 
+        sfp_dev_list[id].bus,
+        sfp_dev_list[id].addr, 
+        addr,
+        value) != ONLP_STATUS_OK)
+    {
+        AIM_LOG_ERROR("sfp->eeprom_readb failed.");
+        fail = 1;
+    }
+    vendor_dev_do_oc(sfp_c_list[id]);
+
+    if(fail == 1) return ONLP_STATUS_E_INTERNAL;
+
+    return ONLP_STATUS_OK;
+}
+
+int onlp_sfpi_control_supported(onlp_oid_id_t oid, onlp_sfp_control_t control, int* rv)
+{
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
+
+int onlp_sfpi_control_get(onlp_oid_id_t oid, onlp_sfp_control_t control, int* value)
+{
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
+
+int onlp_sfpi_control_set(onlp_oid_id_t oid, onlp_sfp_control_t control, int value)
+{
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
+
+int onlp_sfpi_rx_los_bitmap_get(onlp_sfp_bitmap_t* dst)
+{
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
+
+int onlp_sfpi_ioctl(int port, va_list vargs)
+{
+    return ONLP_STATUS_E_UNSUPPORTED;
+}
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/thermali.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/thermali.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/thermali.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/thermali.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,93 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *        Copyright 2014, 2015 Big Switch Networks, Inc.
+ *        Copyright 2017 Delta Networks, Inc.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ * Thermal Sensor Platform Implementation.
+ *
+ ***********************************************************/
+#include <onlp/platformi/base.h>
+#include "vendor_driver_pool.h"
+#include "vendor_i2c_device_list.h"
+
+
+enum onlp_thermal_id
+{
+    THERMAL_RESERVED = 0,
+    THERMAL_1_ON_MAIN_BOARD,
+    THERMAL_2_ON_MAIN_BOARD,
+    THERMAL_3_ON_MAIN_BOARD,
+    THERMAL_4_ON_MAIN_BOARD
+};
+
+#define THERMAL_INFO_ENTRY_INIT(_id, _desc)          \
+    {                                                \
+        {                                            \
+            .id = ONLP_THERMAL_ID_CREATE(_id),       \
+            .description = _desc,                    \
+            .poid = ONLP_OID_CHASSIS,                \
+            .status = ONLP_OID_STATUS_FLAG_PRESENT,  \
+        },                                           \
+        .caps = (ONLP_THERMAL_CAPS_GET_TEMPERATURE), \
+    }
+
+
+static onlp_thermal_info_t onlp_thermal_info[] = {
+    { }, /* Not used */
+    THERMAL_INFO_ENTRY_INIT(THERMAL_1_ON_MAIN_BOARD, "Temp_L0"),
+    THERMAL_INFO_ENTRY_INIT(THERMAL_2_ON_MAIN_BOARD, "Temp_L1"),
+    THERMAL_INFO_ENTRY_INIT(THERMAL_3_ON_MAIN_BOARD, "Temp_L2"),
+    THERMAL_INFO_ENTRY_INIT(THERMAL_4_ON_MAIN_BOARD, "Temp_L3")
+};
+
+
+int onlp_thermali_hdr_get(onlp_oid_t oid, onlp_oid_hdr_t* hdr)
+{
+    *hdr = onlp_thermal_info[ONLP_OID_ID_GET(oid)].hdr;
+    return ONLP_STATUS_OK;
+}
+
+int onlp_thermali_info_get(onlp_oid_t oid, onlp_thermal_info_t* info)
+{
+    int fail = 0;
+    int id = ONLP_OID_ID_GET(oid) - 1;
+    void *busDrv = (void *)vendor_find_driver_by_name(thermal_dev_list[id].bus_drv_name);
+    thermal_dev_driver_t *thermal = 
+        (thermal_dev_driver_t *)vendor_find_driver_by_name(thermal_dev_list[id].dev_drv_name);
+
+    ONLP_OID_INFO_ASSIGN(ONLP_OID_ID_GET(oid), onlp_thermal_info, info);
+
+    vendor_dev_do_oc(thermal_o_list[id]);
+    if(thermal->temp_get(
+        busDrv, 
+        thermal_dev_list[id].bus,
+        thermal_dev_list[id].addr,
+        thermal_dev_list[id].id, 
+        &info->mcelsius) != ONLP_STATUS_OK)
+    {
+        info->mcelsius = 0;
+        fail = 1;
+    }
+    vendor_dev_do_oc(thermal_c_list[id]);
+
+    if(fail == 1) return ONLP_STATUS_E_INVALID;
+
+    return ONLP_STATUS_OK;
+}
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_driver_pool.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_driver_pool.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_driver_pool.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_driver_pool.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,2902 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *           Copyright 2014 Big Switch Networks, Inc.
+ *           Copyright 2014 Accton Technology Corporation.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ *
+ *
+ ***********************************************************/
+#include <linux/i2c-dev.h>
+
+#include <onlp/onlp.h>
+#include <onlplib/file.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <AIM/aim.h>
+#include "vendor_driver_pool.h"
+#include "vendor_i2c_device_list.h"
+
+static int vendor_driver_add(vendor_driver_t *driver);
+
+/*
+    Two I2C bus driver here:
+        SMBUS: using onlp i2c driver
+        IPMB: using raw command
+
+    I2C BUS DRIVER START:
+*/
+
+uint32_t i2c_flag = ONLP_I2C_F_FORCE;
+
+static int smbus_readb(int bus, uint8_t addr, uint16_t offset)
+{
+    //AIM_LOG_ERROR("Function: %s, bus: %d,addr: %d  \n", __FUNCTION__, bus,addr);
+
+    int rv = 0;
+    
+    rv = onlp_i2c_readb(bus, addr, offset, i2c_flag);
+    
+    if(rv < 0)
+    {
+        AIM_LOG_ERROR("I2C readb failed bus: %d, addr: %d, offset: %d.", 
+            bus, addr, offset);
+    }
+    /*else
+    {
+        AIM_LOG_ERROR("I2C readb: bus: %02x, addr: %02x, offset: %02x, value: %02x",
+                bus, addr, offset, rv);
+    }*/
+    return rv; 
+    
+}
+
+#if 1
+#define I2C_SMBUS_READ          1
+#define I2C_SMBUS_WRITE         0
+
+#define I2C_SMBUS_BYTE          1
+#define I2C_SMBUS_BYTE_DATA     2 
+
+#define I2C_SLAVE               0x0703  /* Change slave address */
+#define I2C_SMBUS               0x0720  /* SMBus-level access   */
+
+static int smbus_word_addr_readb(int bus, uint8_t addr, uint16_t offset, uint8_t *byte)
+{
+    int fd = -1;
+    uint8_t upper_addr, lower_addr;
+    union i2c_smbus_data data;
+    struct i2c_smbus_ioctl_data args;
+    int rv = -1;
+
+    /* Open the SMBus device */
+    fd = onlp_i2c_open(bus, addr, i2c_flag);
+    if(fd < 0)
+    {
+        AIM_LOG_ERROR("I2C word address readb open failed bus: %d, addr: %d, offset: %d.", 
+                      bus, addr, offset);
+        return -1;
+    }
+
+    /* Dev_Addr + W + Upper_Data_Addr + Lower_Data_Addr */
+    upper_addr = (offset >> 8) & 0xFF;
+    lower_addr = offset & 0xFF;
+
+    args.read_write = I2C_SMBUS_WRITE;
+    args.command = upper_addr;
+    args.size = I2C_SMBUS_BYTE_DATA;
+    data.byte = lower_addr;
+    args.data = &data;
+
+    rv = ioctl(fd, I2C_SMBUS, &args);
+
+    /* Dev_Addr + R + Data */
+    args.read_write = I2C_SMBUS_READ;
+    args.command = 0;
+    args.size = I2C_SMBUS_BYTE;
+    data.byte = 0;
+    args.data = &data;
+
+    rv = ioctl(fd, I2C_SMBUS, &args);
+
+    if(rv < 0)
+    {
+        AIM_LOG_ERROR("I2C word address readb failed bus: %d, addr: %d, offset: %d.", 
+                      bus, addr, offset);
+        close(fd);
+        return -1;
+    }
+    else
+        *byte = (uint8_t)(data.byte & 0xFF);
+
+    close(fd);
+    return 0;
+}
+#endif
+
+static int smbus_writeb(int bus, uint8_t addr, uint16_t offset, uint8_t byte)
+{
+    int rv = 0;
+    rv = onlp_i2c_writeb(bus, addr, offset, byte, i2c_flag);
+    if(rv < 0)
+    {
+        AIM_LOG_ERROR("I2C writeb failed bus: %d, addr: %d, offset: %d.", 
+            bus, addr, offset);
+    }
+    /*else
+    {
+        AIM_LOG_ERROR("I2C writeb: bus: %02x, addr: %02x, offset: %02x, value: %02x",
+                bus, addr, offset, byte);
+    }*/
+    return rv;
+}
+
+static int smbus_readw(int bus, uint8_t addr, uint16_t offset)
+{
+    int rv = 0;
+    rv = onlp_i2c_readw(bus, addr, offset, i2c_flag);
+    if(rv < 0)
+    {
+        AIM_LOG_ERROR("I2C readw failed bus: %d, addr: %d, offset: %d.", 
+            bus, addr, offset);
+    }
+    return rv;
+}
+
+static int smbus_writew(int bus, uint8_t addr, uint16_t offset, uint16_t word)
+{
+    int rv = 0;
+    rv = onlp_i2c_writew(bus, addr, offset, word, i2c_flag);
+    if(rv < 0)
+    {
+        AIM_LOG_ERROR("I2C writew failed bus: %d, addr: %d, offset: %d.", 
+            bus, addr, offset);
+    }
+    return rv;
+}
+
+static int smbus_block_read(int bus, uint8_t addr, uint16_t offset, int size, uint8_t* rdata)
+{
+    int rv = 0;
+    rv = onlp_i2c_block_read(bus, addr, offset, size, rdata, i2c_flag);
+    if(rv < 0)
+    {
+        AIM_LOG_ERROR("I2C block read failed bus: %d, addr: %d, offset: %d.", 
+            bus, addr, offset);
+    }
+    /*else
+    {
+        AIM_LOG_ERROR("I2C block_read: bus: %02x, addr: %02x, offset: %02x, value: %02x",
+                bus, addr, offset, rv);
+    }*/
+    return rv;
+}
+
+static i2c_bus_driver_t smbus_functions = 
+{
+    smbus_readb,
+    smbus_writeb,
+    smbus_readw,
+    smbus_writew,
+    smbus_block_read
+};
+
+static int smbus_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "I2C", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &smbus_functions;
+
+    return vendor_driver_add(driver);
+}
+
+static int ipmb_readb(int bus, uint8_t addr, uint16_t offset)
+{
+    int rv = 0, idx = 0;
+    char ipmi_cmd[80], rv_char[256], *delim = " ", *tmp;
+    uint8_t rv_data[32] = {0};
+
+    sprintf(ipmi_cmd, "ipmitool raw 0x3c 0x01 %d %d %d %d", bus, addr, offset, 1);
+    if (vendor_system_call_get(ipmi_cmd, rv_char) != 0)
+    {
+        AIM_LOG_ERROR("IPMITOOL command: \"%s\": Get Data Failed (ret: %d)", ipmi_cmd);
+        return ONLP_STATUS_E_INTERNAL;
+    }
+ 
+    tmp = strtok(rv_char, delim);
+
+    while (tmp != NULL)
+    {
+        rv_data[idx] = strtol(tmp,NULL,16);
+        tmp = strtok (NULL, delim);
+        idx++;
+    }
+
+    rv = rv_data[0] & 0xff;
+
+    /*
+    AIM_LOG_ERROR("IPMITOOL readb: bus: %02x, addr: %02x, offset: %02x, value: %x",
+                bus, addr, offset, rv);
+    */
+    return rv;
+}
+
+static int ipmb_writeb(int bus, uint8_t addr, uint16_t offset, uint8_t byte)
+{
+    int rv = 0;
+    char ipmi_cmd[80];
+
+    sprintf(ipmi_cmd, "ipmitool raw 0x3c 0x02 %d %d %d %d %d > /dev/null", bus, addr, offset, 1, byte);
+    if (vendor_system_call_set(ipmi_cmd) != 0)
+    {
+        AIM_LOG_ERROR("IPMITOOL command: \"%s\": Set Data Failed.", ipmi_cmd);
+        return ONLP_STATUS_E_INTERNAL;
+    }
+    /*else
+    {
+        AIM_LOG_ERROR("IPMITOOL writeb: bus: %02x, addr: %02x, offset: %02x, data: %02x",
+                bus, addr, offset, byte);
+    }*/
+    
+    return rv;
+}
+
+static int ipmb_readw(int bus, uint8_t addr, uint16_t offset)
+{
+    int rv = 0, idx = 0;
+    char ipmi_cmd[80], rv_char[256], *delim = " ", *tmp;
+    uint16_t rv_data[32] = {0};
+
+    sprintf(ipmi_cmd, "ipmitool raw 0x3c 0x01 %d %d %d %d", bus, addr, offset, 2);
+    if (vendor_system_call_get(ipmi_cmd, rv_char) != 0)
+    {
+        AIM_LOG_ERROR("IPMITOOL command: \"%s\": Get Data Failed.", ipmi_cmd);
+        return ONLP_STATUS_E_INTERNAL;
+    }
+        
+    tmp = strtok(rv_char, delim);
+
+    while (tmp != NULL)
+    {
+        rv_data[idx] = strtol(tmp,NULL,16);
+        tmp = strtok (NULL, delim);
+        idx++;
+    }
+
+    rv = (rv_data[0] & 0xff) + ((rv_data[1]&0xff) << 8);
+
+    /*
+    AIM_LOG_ERROR("IPMITOOL readw: bus: %02x, addr: %02x, offset: %02x, value: %x",
+                bus, addr, offset, rv);
+    */
+
+    return rv;
+}
+
+static int ipmb_writew(int bus, uint8_t addr, uint16_t offset, uint16_t word)
+{
+    int rv = 0;
+    char ipmi_cmd[80];
+
+    sprintf(ipmi_cmd, "ipmitool raw 0x3c 0x02 %d %d %d %d %d > /dev/null", bus, addr, offset, 2, word);
+    if (vendor_system_call_set(ipmi_cmd) != 0)
+    {
+        AIM_LOG_ERROR("IPMITOOL command: \"%s\": Set Data Failed.", ipmi_cmd);
+        return ONLP_STATUS_E_INTERNAL;
+    }
+
+    /*
+    AIM_LOG_ERROR("IPMITOOL writew: bus: %02x, addr: %02x, offset: %02x, value: %x",
+                bus, addr, offset, word);
+    */
+    
+    return rv;
+}
+
+static int ipmb_block_read(int bus, uint8_t addr, uint16_t offset, int size, uint8_t* rdata)
+{
+    int rv = 0, idx = 0;
+    char ipmi_cmd[80], rv_char[256], *delim = " ", *tmp;
+    uint8_t rv_data[32] = {0};
+
+    if (size > 64)
+    {
+        AIM_LOG_ERROR("The limitation of size is 64.");
+        return ONLP_STATUS_E_INTERNAL;
+    }
+
+    sprintf(ipmi_cmd, "ipmitool raw 0x3c 0x01 %d %d %d %d", bus, addr, offset, size+1);
+    if (vendor_system_call_get(ipmi_cmd, rv_char) != 0)
+    {
+        AIM_LOG_ERROR("IPMITOOL command: \"%s\": Block read Failed.", ipmi_cmd);
+        return ONLP_STATUS_E_INTERNAL;
+    }
+        
+    tmp = strtok(rv_char, delim);
+
+    while (tmp != NULL)
+    {
+        rv_data[idx] = strtol(tmp,NULL,16);
+        tmp = strtok (NULL, delim);
+        idx++;
+    }
+
+    for(idx = 0; idx < size; idx++)
+        rdata[idx] = rv_data[idx+1] & 0xff;
+
+    return rv;
+}
+
+static i2c_bus_driver_t ipmb_functions = 
+{
+    ipmb_readb,
+    ipmb_writeb,
+    ipmb_readw,
+    ipmb_writew,
+    ipmb_block_read
+};
+
+static int ipmb_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "IPMB", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &ipmb_functions;
+
+    return vendor_driver_add(driver);
+}
+
+/*
+    I2C BUS DRIVER END:
+*/
+
+/*
+    IPMI BUS DRIVER START:
+*/
+static int ipmi_get(int bus, char *cmd, char *filter, char *data, uint32_t dlen)
+{
+    char sys_cmd[128];
+    char rv_char[256];
+
+    if (bus) {}
+
+    if (!cmd || !filter)
+        return 0;
+
+    sprintf(sys_cmd, "ipmitool %s %s", cmd, filter);
+    if (vendor_system_call_get(sys_cmd, rv_char) != 0)
+        return 0;
+
+    memcpy(data, rv_char, (dlen-1));
+    data[dlen-1] = '\0';
+
+    return 0;
+
+}
+
+static int ipmi_set(int bus, char *cmd, char *filter)
+{
+    char sys_cmd[128];
+    
+    if (bus) {}
+
+    if (!cmd || !filter)
+        return 0;
+
+    sprintf(sys_cmd, "ipmitool %s %s > /dev/null", cmd, filter);
+
+    return vendor_system_call_set(sys_cmd);
+
+}
+
+ipmi_bus_driver_t ipmi_functions = 
+{
+    ipmi_get,
+    ipmi_set
+};
+
+static int ipmi_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "IPMI", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &ipmi_functions;
+
+    return vendor_driver_add(driver);
+}
+
+/*
+    IPMI BUS DRIVER END:
+*/
+
+/*
+    DEVICE DRIVER START:
+*/
+
+/* CPLD DEVICE START*/
+static int cpld_read(void *busDrvPtr, int bus, uint8_t addr, uint8_t offset, uint8_t *value)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+
+    rv = i2c->readb(bus, addr, offset);
+    if(rv >= 0)
+    {
+        *value = rv;
+    }
+
+    return rv;
+}
+
+static int cpld_write(void *busDrvPtr, int bus, uint8_t addr, uint8_t offset, uint8_t value)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+
+    rv = i2c->writeb(bus, addr, offset, value);
+
+    return rv;
+}
+
+static cpld_dev_driver_t cpld_functions =
+{
+    cpld_read,
+    cpld_write
+};
+
+static int cpld_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "CPLD", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &cpld_functions;
+
+    return vendor_driver_add(driver);
+}
+/* CPLD DEVICE END*/
+
+/* EEPROM DEVICE START*/
+static int eeprom_readb(void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint16_t len, uint8_t *buf)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0, index = 0;
+
+    for(index = 0; index < len; index++)
+    {
+        rv = i2c->readb(bus, addr, offset+index);
+        if(rv < 0)
+        {
+            return ONLP_STATUS_E_INTERNAL;
+        }
+        *(buf+index) = (uint8_t) (rv & 0xff);
+    }
+    
+    return 0;
+}
+
+static int eeprom_writeb(void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint16_t len, uint8_t *buf)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0, index = 0;
+
+    for(index = 0; index<len; index++)
+    {
+        rv = i2c->writeb(bus, addr, offset+index, *(buf+index));
+        usleep(5000);
+        if(rv < 0)
+        {
+            return ONLP_STATUS_E_INTERNAL;
+        }
+    }
+
+    return 0;
+}
+
+static int eeprom_load(void *busDrvPtr, int bus, uint8_t addr, uint8_t *buf)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    int i;
+    uint8_t *p = buf;
+
+    if (i2c)
+    {
+        rv = i2c->block_read(bus, addr, 0, 256, buf);
+    }
+    else
+    {
+        for (i = 0;i < 256;i++)
+        {
+            rv = smbus_word_addr_readb(bus, addr, 0x800+i, p+i);
+        }
+    }
+
+    return rv;
+}
+
+static eeprom_dev_driver_t eeprom_functions = 
+{
+    eeprom_readb,
+    eeprom_writeb,
+    eeprom_load,
+};
+
+static int eeprom_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "EEPROM", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &eeprom_functions;
+    
+    return vendor_driver_add(driver);
+}
+/* EEPROM DEVICE END*/
+
+/* FAN DEVICE EMC2305 START*/
+static const uint8_t fan_config1_reg[] = 
+{ 
+    0x32, 0x42, 0x52, 0x62, 0x72
+};
+
+static const uint8_t fan_tach_reg[][2] = 
+{
+    {0x3e, 0x3f}, {0x4e, 0x4f}, {0x5e, 0x5f}, {0x6e, 0x6f}, {0x7e, 0x7f},
+};
+
+static const uint8_t fan_tach_target_reg[][2] = 
+{
+    {0x3d, 0x3c}, {0x4d, 0x4c}, {0x5d, 0x5c}, {0x6d, 0x6c}, {0x7d, 0x7c},
+};
+
+static int emc2305_rpm_get(void *busDrvPtr, int bus, uint8_t addr, int id, int *rpm)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint16_t tach_count = 0, htach = 0, ltach = 0;
+
+    rv = i2c->readb(bus, addr, fan_tach_reg[id][0]);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    htach = rv;
+
+    rv = i2c->readb(bus, addr, fan_tach_reg[id][1]);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    ltach = rv;
+
+    tach_count = (((htach << 8) | ltach) >> 0x3);
+
+    if(tach_count == 0)
+    {
+        *rpm = 0;
+        return 0;
+    }
+        
+    *rpm = 7864320 / tach_count;
+
+    return 0;
+}
+
+static int emc2305_rpm_set(void *busDrvPtr, int bus, uint8_t addr, int id, int rpm)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint16_t tach_count = 0, htach = 0, ltach = 0;
+
+    tach_count = ((7864320 / rpm) << 0x3);
+    htach =  (tach_count & 0xff00) >> 8;
+    ltach =  tach_count & 0xff;
+
+    rv = i2c->writeb(bus, addr, fan_tach_target_reg[id][0], (uint8_t) htach);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    rv = i2c->writeb(bus, addr, fan_tach_target_reg[id][1], (uint8_t) ltach);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    /* Set to RPM Mode */
+    rv = i2c->writeb(bus, addr, fan_config1_reg[id], 0xab);
+    return 0;
+}
+
+static fan_dev_driver_t emc2305_functions = 
+{
+    emc2305_rpm_get,
+    emc2305_rpm_set
+};
+
+static int emc2305_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "EMC2305", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &emc2305_functions;
+
+    return vendor_driver_add(driver);
+}
+/* FAN DEVICE EMC2305 END*/
+
+/*THERMAL DEVICE TMP75 START*/
+
+#define TMP75_TEMP_REG        0x00
+#define TMP75_CONFIG_REG      0x01
+#define TMP75_TLOW_REG        0x02
+#define TMP75_THIGH_REG       0x03
+
+static int tmp75_temp_get(void *busDrvPtr, int bus, uint8_t addr, int id, int *temperature)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0, is_negative = 0;
+ 
+    rv = i2c->readb(bus, addr, TMP75_TEMP_REG);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    if (rv & 0x800)
+    {
+        is_negative = 1;
+        rv = ~(rv) + 1; /* 2's complement */
+        rv &= 0x7ff;
+	}
+
+    rv = (((rv << 8) | (rv >> 8)) >> 4);
+    *temperature = rv * 62.5;
+    if(is_negative) *temperature *= -1;
+
+    return 0;
+}
+
+static int tmp75_limit_get(void *busDrvPtr, int bus, uint8_t addr, int id, int type, int *temperature)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t limitAddr = 0;
+
+    switch (type)
+    {
+        case VENDOR_THERMAL_LOW_THRESHOLD:
+            limitAddr = TMP75_TLOW_REG;
+            break;
+        case VENDOR_THERMAL_HIGH_THRESHOLD:
+            limitAddr = TMP75_THIGH_REG;
+            break;
+        default:
+            AIM_LOG_ERROR("VENDOR: TMP75 unknow limit type!");
+            break;
+    }
+
+    rv = i2c->readb(bus, addr, limitAddr);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    
+    *temperature = rv*1000;
+
+    return 0;
+}
+
+static int tmp75_limit_set(void *busDrvPtr, int bus, uint8_t addr, int id, int type, int temperature)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t limitAddr = 0;
+
+    switch (type)
+    {
+        case VENDOR_THERMAL_LOW_THRESHOLD:
+            limitAddr = TMP75_TLOW_REG;
+            break;
+        case VENDOR_THERMAL_HIGH_THRESHOLD:
+            limitAddr = TMP75_THIGH_REG;
+            break;
+        default:
+            AIM_LOG_ERROR("VENDOR: TMP75 unknow limit type!");
+            break;
+    }
+
+    rv = i2c->writeb(bus, addr, limitAddr, (uint16_t) temperature);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    return 0;
+}
+
+static thermal_dev_driver_t tmp75_functions =
+{
+    tmp75_temp_get,
+    tmp75_limit_get,
+    tmp75_limit_set
+};
+
+static int tmp75_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "TMP75", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &tmp75_functions;
+
+    return vendor_driver_add(driver);
+}
+/*THERMAL DEVICE TMP75 END*/
+
+/*THERMAL DEVICE TMP461 START*/
+
+#define TMP461_HIGH_ADDRESS    0
+#define TMP461_LOW_ADDRESS     1
+
+static const uint8_t tmp461_thermal_reg[2] = { 0x1, 0x10 };
+static const uint8_t tmp461_limit_reg_read_high[2] = { 0x7, 0x8 };
+static const uint8_t tmp461_limit_reg_read_low[2] = { 0x13, 0x14 };
+static const uint8_t tmp461_limit_reg_write_high[2] = { 0xd, 0xe };
+static const uint8_t tmp461_limit_reg_write_low[2] = { 0x13, 0x14 };
+
+static int tmp461_temp_get(void *busDrvPtr, int bus, uint8_t addr, int id, int *temperature)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint16_t temp_high = 0, temp_low = 0, is_negative = 0;
+    rv = i2c->readb(bus, addr, tmp461_thermal_reg[TMP461_HIGH_ADDRESS]);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    temp_high = (uint16_t) rv;
+
+    rv = i2c->readb(bus, addr, tmp461_thermal_reg[TMP461_LOW_ADDRESS]);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    temp_low = (uint16_t) rv;
+
+    if (temp_high & 0x80)
+    {
+        is_negative = 1;
+        temp_high = ~temp_high + 1; /* 2's complement */
+        temp_high &= 0xff;
+    }
+
+    *temperature = temp_high*1000 + (temp_low >> 4) * 62.5;
+    if (is_negative) *temperature *= -1;
+
+    return 0;
+}
+
+static int tmp461_limit_get(void *busDrvPtr, int bus, uint8_t addr, int id, int type, int *temperature)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t limitAddr_high = 0, limitAddr_low = 0;
+    uint16_t temp_high = 0, temp_low = 0, is_negative = 0;
+
+    switch (type)
+    {
+        case VENDOR_THERMAL_LOW_THRESHOLD:
+            limitAddr_high = tmp461_limit_reg_read_high[TMP461_LOW_ADDRESS];
+            limitAddr_low = tmp461_limit_reg_read_low[TMP461_LOW_ADDRESS];
+            break;
+        case VENDOR_THERMAL_HIGH_THRESHOLD:
+            limitAddr_high = tmp461_limit_reg_read_high[TMP461_HIGH_ADDRESS];
+            limitAddr_low = tmp461_limit_reg_read_low[TMP461_HIGH_ADDRESS];
+            break;
+        default:
+            AIM_LOG_ERROR("VENDOR: TMP461 unknow limit type!");
+            break;
+    }
+
+    rv = i2c->readb(bus, addr, limitAddr_high);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    temp_high = (uint16_t) rv;
+
+    rv = i2c->readb(bus, addr, limitAddr_low);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    temp_low = (uint16_t) rv;
+
+    if (temp_high & 0x80)
+    {
+        is_negative = 1;
+        temp_high = ~temp_high + 1; /* 2's complement */
+        temp_high &= 0xff;
+    }
+
+    *temperature = temp_high*1000 + (temp_low >> 4) * 62.5;
+    if (is_negative) *temperature *= -1;
+
+    return 0;
+}
+
+static int tmp461_limit_set(void *busDrvPtr, int bus, uint8_t addr, int id, int type, int temperature)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t limitAddr_high = 0, limitAddr_low = 0;
+    
+    switch (type)
+    {
+        case VENDOR_THERMAL_LOW_THRESHOLD:
+            limitAddr_high = tmp461_limit_reg_write_high[TMP461_LOW_ADDRESS];
+            limitAddr_low = tmp461_limit_reg_write_low[TMP461_LOW_ADDRESS];
+            break;
+        case VENDOR_THERMAL_HIGH_THRESHOLD:
+            limitAddr_high = tmp461_limit_reg_write_high[TMP461_HIGH_ADDRESS];
+            limitAddr_low = tmp461_limit_reg_write_low[TMP461_HIGH_ADDRESS];
+            break;
+        default:
+            AIM_LOG_ERROR("VENDOR: TMP461 unknow limit type!");
+            break;
+    }
+
+    rv = i2c->writeb(bus, addr, limitAddr_high, (uint8_t) temperature);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    rv = i2c->writeb(bus, addr, limitAddr_low, 0);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    return 0;
+}
+
+static thermal_dev_driver_t tmp461_functions =
+{
+    tmp461_temp_get,
+    tmp461_limit_get,
+    tmp461_limit_set
+};
+
+static int tmp461_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "TMP461", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &tmp461_functions;
+
+    return vendor_driver_add(driver);
+}
+/*THERMAL DEVICE TMP461 END*/
+
+/*PSU DEVICE PMBUS START*/
+
+typedef enum
+{
+    PMBUS_VOUT_MODE         = 0x20,
+    PMBUS_FAN_CONFIG_12     = 0x3A,
+    PMBUS_FAN_CMD_1         = 0x3B,
+    PMBUS_FAN_CMD_2         = 0x3C,
+    PMBUS_FAN_CONFIG_34     = 0x3D,
+    PMBUS_FAN_CMD_3         = 0x3E,
+    PMBUS_FAN_CMD_4         = 0x3F,
+    PMBUS_READ_FAN_SPEED_1  = 0x90,
+    PMBUS_READ_FAN_SPEED_2  = 0x91,
+    PMBUS_READ_FAN_SPEED_3  = 0x92,
+    PMBUS_READ_FAN_SPEED_4  = 0x93,
+    PMBUS_AC_VOLTAGE_IN     = 0x88,
+    PMBUS_AC_AMPERE_IN      = 0x89,
+    PMBUS_DC_VOLTAGE_OUT    = 0x8B,
+    PMBUS_DC_AMPERE_OUT     = 0x8C,
+    PMBUS_READ_TEMP_1       = 0x8D,
+    PMBUS_READ_TEMP_2       = 0x8E,
+    PMBUS_READ_TEMP_3       = 0x8F,
+    PMBUS_DC_WATT_OUT       = 0x96,
+    PMBUS_AC_WATT_IN        = 0x97,
+    PMBUS_MODEL_NAME        = 0x9A,
+    PMBUS_VERSION           = 0x9B,
+    PMBUS_SERIAL_NUMBER     = 0x9E,
+}pmbus_command_t;
+
+typedef enum
+{
+    LINEAR_DATA_FORMAT,
+    DIRECT_DATA_FORMAT,
+    FAN_SPEED_DATA_FORMAT
+}pmbus_algorithm_t;
+
+typedef struct
+{
+    pmbus_command_t command;
+    pmbus_algorithm_t algorithm;
+    uint16_t dataLen;
+}pmbus_command_info_t;
+
+static pmbus_command_info_t pmbus_command_info[] =
+{
+    {PMBUS_VOUT_MODE,           DIRECT_DATA_FORMAT,     1},
+    {PMBUS_FAN_CONFIG_12,       LINEAR_DATA_FORMAT,     1},
+    {PMBUS_FAN_CMD_1,           LINEAR_DATA_FORMAT,     2},
+    {PMBUS_FAN_CMD_2,           LINEAR_DATA_FORMAT,     2},
+    {PMBUS_FAN_CONFIG_34,       LINEAR_DATA_FORMAT,     1},
+    {PMBUS_FAN_CMD_3,           LINEAR_DATA_FORMAT,     2},
+    {PMBUS_FAN_CMD_4,           LINEAR_DATA_FORMAT,     2},
+    {PMBUS_READ_FAN_SPEED_1,    FAN_SPEED_DATA_FORMAT,  2},
+    {PMBUS_READ_FAN_SPEED_2,    FAN_SPEED_DATA_FORMAT,  2},
+    {PMBUS_READ_FAN_SPEED_3,    FAN_SPEED_DATA_FORMAT,  2},
+    {PMBUS_READ_FAN_SPEED_4,    FAN_SPEED_DATA_FORMAT,  2},
+    {PMBUS_AC_VOLTAGE_IN,       LINEAR_DATA_FORMAT,     2},
+    {PMBUS_AC_AMPERE_IN,        LINEAR_DATA_FORMAT,     2},
+    {PMBUS_DC_VOLTAGE_OUT,      DIRECT_DATA_FORMAT,     2},
+    {PMBUS_DC_AMPERE_OUT,       LINEAR_DATA_FORMAT,     2},
+    {PMBUS_READ_TEMP_1,         LINEAR_DATA_FORMAT,     2},
+    {PMBUS_READ_TEMP_2,         LINEAR_DATA_FORMAT,     2},
+    {PMBUS_READ_TEMP_3,         LINEAR_DATA_FORMAT,     2},
+    {PMBUS_DC_WATT_OUT,         LINEAR_DATA_FORMAT,     2},
+    {PMBUS_AC_WATT_IN,          LINEAR_DATA_FORMAT,     2},
+    {PMBUS_MODEL_NAME,          LINEAR_DATA_FORMAT,     3},
+    {PMBUS_VERSION,             LINEAR_DATA_FORMAT,     3},
+    {PMBUS_SERIAL_NUMBER,       LINEAR_DATA_FORMAT,     3}
+};
+
+static int get_pmbus_algorithm_result(pmbus_algorithm_t algorithm, uint16_t *data)
+{
+    switch (algorithm)
+    {
+        case FAN_SPEED_DATA_FORMAT:
+            return (*data & 0x7ff) * pow(2, ( (*data >> 11) ) & 0x1f);
+        
+        case LINEAR_DATA_FORMAT:
+            return (*data & 0x7ff) * 1000 / pow(2, (~(*data >> 11) + 1) & 0x1f);
+
+        case DIRECT_DATA_FORMAT:
+            return data[0] * 1000 / pow(2, (~data[1] + 1) & 0x1f);
+
+        default:
+            AIM_LOG_ERROR("VENDOR: Cannot find algorithm!");
+            return -1;
+    }
+
+    return 0;
+}
+
+static pmbus_command_info_t *get_pmbus_command_info(pmbus_command_t command)
+{
+    int i, cnt = sizeof(pmbus_command_info) / sizeof(pmbus_command_info_t);
+
+    for (i = 0; i < cnt; i++)
+    {
+        if (pmbus_command_info[i].command == command) {
+            return &pmbus_command_info[i];
+        }
+    }
+
+    return NULL;
+}
+
+static int pmbus_command_data_get(
+    i2c_bus_driver_t *i2c, 
+    int bus, 
+    uint8_t addr,
+    pmbus_command_info_t *info, 
+    uint16_t *pmbusData)
+{
+    int rv = 0;
+
+    if(info == NULL) return ONLP_STATUS_E_INTERNAL;
+    if(info->dataLen == 1)
+    {
+        rv = i2c->readb(bus, addr, info->command);    
+        if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+        *pmbusData = (uint8_t) rv;
+        return 0;
+    }
+    else if(info->dataLen == 2)
+    {
+        rv = i2c->readw(bus, addr, info->command);    
+        if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+        *pmbusData = (uint16_t) rv;
+        return 0;
+    }
+    
+    return -1;
+}
+
+static int pmbus_command_string_get(
+    i2c_bus_driver_t *i2c, 
+    int bus, 
+    uint8_t addr,
+    pmbus_command_info_t *info, 
+    char *string)
+{
+    int rv = 0; 
+    uint16_t len;
+
+    if(info == NULL) return ONLP_STATUS_E_INTERNAL;
+
+    rv = i2c->readb(bus, addr, info->command);  
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+    len = (uint16_t) rv;
+
+    rv = i2c->block_read(bus, addr, info->command, len, (uint8_t *) string);
+   
+    return rv;
+}
+
+static int pmbus_model_get(void *busDrvPtr, int bus, uint8_t addr, char *model)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    pmbus_command_info_t *info = get_pmbus_command_info(PMBUS_MODEL_NAME);
+    rv = pmbus_command_string_get(i2c, bus, addr, info, model);
+    return rv;
+}
+
+static int pmbus_serial_get(void *busDrvPtr, int bus, uint8_t addr, char *serial)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    pmbus_command_info_t *info = get_pmbus_command_info(PMBUS_SERIAL_NUMBER);
+    rv = pmbus_command_string_get(i2c, bus, addr, info, serial);
+    return rv;
+}
+
+static int pmbus_volt_get(void *busDrvPtr, int bus, uint8_t addr, int *volt)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    
+    uint16_t pmbus_data[2] = {0};
+    pmbus_command_info_t *info = NULL;
+    info = get_pmbus_command_info(PMBUS_DC_VOLTAGE_OUT);
+    rv = pmbus_command_data_get(i2c, bus, addr, info, &pmbus_data[0]);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    info = get_pmbus_command_info(PMBUS_VOUT_MODE);
+    rv = pmbus_command_data_get(i2c, bus, addr, info, &pmbus_data[1]);
+    if(rv < 0) return ONLP_STATUS_E_INTERNAL;
+
+    *volt = get_pmbus_algorithm_result(info->algorithm, pmbus_data);
+
+    return rv;
+}
+
+static int pmbus_amp_get(void *busDrvPtr, int bus, uint8_t addr, int *amp)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+
+    uint16_t pmbus_data = 0;
+    pmbus_command_info_t *info = get_pmbus_command_info(PMBUS_DC_AMPERE_OUT);
+    rv = pmbus_command_data_get(i2c, bus, addr, info, &pmbus_data);
+    if(rv != 0) return ONLP_STATUS_E_INTERNAL;
+
+    *amp = get_pmbus_algorithm_result(info->algorithm, &pmbus_data);
+
+    return rv;
+}
+
+static int pmbus_watt_get(void *busDrvPtr, int bus, uint8_t addr, int *watt)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+
+    uint16_t pmbus_data = 0;
+    pmbus_command_info_t *info = get_pmbus_command_info(PMBUS_DC_WATT_OUT);
+    rv = pmbus_command_data_get(i2c, bus, addr, info, &pmbus_data);
+    if(rv != 0) return ONLP_STATUS_E_INTERNAL;
+    
+    *watt = get_pmbus_algorithm_result(info->algorithm, &pmbus_data);
+
+    return rv;
+}
+
+static int pmbus_fan_rpm_get(void *busDrvPtr, int bus, uint8_t addr, int id, int *rpm)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+
+    uint16_t pmbus_data = 0;
+    pmbus_command_info_t *info = get_pmbus_command_info(PMBUS_READ_FAN_SPEED_1);
+    rv = pmbus_command_data_get(i2c, bus, addr, info, &pmbus_data);
+    if(rv != 0) return ONLP_STATUS_E_INTERNAL;
+    
+    *rpm = get_pmbus_algorithm_result(info->algorithm, &pmbus_data);
+
+    return rv;
+}
+
+static int pmbus_fan_rpm_set(void *busDrvPtr, int bus, uint8_t addr, int id, int rpm)
+{
+    AIM_LOG_ERROR("VENDOR: It is not supported in PMBUS.");
+    return ONLP_STATUS_E_INTERNAL;
+}
+
+static psu_dev_driver_t pmbus_psu_functions =
+{
+    pmbus_model_get,
+    pmbus_serial_get,
+    pmbus_volt_get,
+    pmbus_amp_get,
+    pmbus_watt_get
+};
+
+static fan_dev_driver_t pmbus_fan_functions = 
+{
+    pmbus_fan_rpm_get,
+    pmbus_fan_rpm_set,
+};
+
+static int pmbus_psu_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "PMBUS_PSU", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &pmbus_psu_functions;
+
+    return vendor_driver_add(driver);
+}
+
+static int pmbus_fan_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "PMBUS_FAN", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &pmbus_fan_functions;
+
+    return vendor_driver_add(driver);
+}
+
+/*PSU DEVICE PMBUS END*/
+
+/*SFP and QSFP CONTROL DEFINE*/
+
+typedef enum 
+{
+    /* Shared QSFP and SFP fields: */
+    SFF_FIELD_MIN,
+    IDENTIFIER, /* Type of Transceiver */
+    STATUS,     /* Support flags for upper pages */
+    CHANNEL_LOS_INDICATOR, /* TX and RX LOS */
+    CHANNEL_TX_FAULT, 
+    TEMPERATURE_ALARMS,
+    VCC_ALARMS, /* Voltage */
+    CHANNEL_RX_PWR_ALARMS,
+    CHANNEL_TX_BIAS_ALARMS,
+    TEMPERATURE,
+    VCC, /* Voltage */
+    CHANNEL_RX_PWR,
+    CHANNEL_TX_PWR,
+    CHANNEL_TX_BIAS,
+    CHANNEL_TX_DISABLE,
+    POWER_CONTROL,
+    PAGE_SELECT_BYTE, /*SFF8436/SFF8636*/
+
+    DIAGNOSTIC_MONITORING_TYPE,   /* SFF8472 Diagnostic monitoring implemented */
+    EXTERNAL_CALIBRATION,    /* SFF8472 diagnostic calibration constants */ 
+    SFF_FIELD_MAX /* keep this the last */
+
+}sff_field_t;
+
+/*SFP DEVICE SFF8636 START*/
+
+#define SFF8636_PAGE_CONTROL 127
+#define SFF8636_UPPER_PAGE_START_OFFSET 128
+#define SFP_EEPROM_SIZE 256
+#define SFP_EEPROM_PAGE_SIZE 128
+#define CONTROL_IS_SUPPORT 1
+#define CONTROL_IS_NOT_SUPPORT 0
+
+typedef enum
+{
+    SFF8636_EEPROM_BASE_PAGE, 
+    SFF8636_EEPROM_PAGE0 = 0,
+}sff8636_page_t;
+
+typedef struct
+{
+    sff_field_t field;
+    uint8_t page;
+    uint16_t offset;
+    uint16_t length;
+}sff8636_field_map_t;
+
+static uint8_t get_sfp_flat_mem(i2c_bus_driver_t *i2c, int bus, uint8_t addr);
+static uint8_t filter_sff8636_control_value_for_get(int control, uint8_t *eeprom_data, int *combined_data);
+static uint8_t filter_sff8636_control_value_for_set(int control, uint8_t *eeprom_data, int *write_status);
+static sff_field_t get_sff8636_control_field(int control);
+static int eeprom_read_lowermap(i2c_bus_driver_t *i2c, int bus, uint8_t addr, uint8_t *data);
+static int eeprom_uppermap_change_page(i2c_bus_driver_t *i2c, int bus, uint8_t addr, uint8_t page);
+static int eeprom_read_uppermap_by_page(i2c_bus_driver_t *i2c, int bus, uint8_t addr, uint8_t page, uint8_t *data);
+static int get_sff8636_field(sff_field_t field, sff8636_field_map_t **info);
+static int get_sff8636_value_from_eeprom(i2c_bus_driver_t *i2c, int bus, uint8_t addr, sff8636_field_map_t *info, uint8_t *value);
+static int set_sff8636_value_to_eeprom(i2c_bus_driver_t *i2c, int bus, uint8_t addr, sff8636_field_map_t *info, uint8_t *value);
+
+static sff8636_field_map_t sff8636_field_map[] = {
+    {IDENTIFIER, SFF8636_EEPROM_BASE_PAGE, 0, 1},
+    {STATUS, SFF8636_EEPROM_BASE_PAGE, 1, 2},
+    {CHANNEL_LOS_INDICATOR, SFF8636_EEPROM_BASE_PAGE, 3, 1},
+    {CHANNEL_TX_FAULT, SFF8636_EEPROM_BASE_PAGE, 4, 1},
+    {VCC_ALARMS, SFF8636_EEPROM_BASE_PAGE, 7, 1},
+    {CHANNEL_RX_PWR_ALARMS, SFF8636_EEPROM_BASE_PAGE, 9, 2},
+    {CHANNEL_TX_BIAS_ALARMS, SFF8636_EEPROM_BASE_PAGE, 11, 2},
+    {TEMPERATURE, SFF8636_EEPROM_BASE_PAGE, 22, 2},
+    {VCC, SFF8636_EEPROM_BASE_PAGE, 26, 2},
+    {CHANNEL_RX_PWR, SFF8636_EEPROM_BASE_PAGE, 34, 8},
+    {CHANNEL_TX_BIAS, SFF8636_EEPROM_BASE_PAGE, 42, 8},
+    {CHANNEL_TX_PWR, SFF8636_EEPROM_BASE_PAGE, 50, 8},
+    {CHANNEL_TX_DISABLE, SFF8636_EEPROM_BASE_PAGE, 86, 1},
+    {POWER_CONTROL, SFF8636_EEPROM_BASE_PAGE, 93, 1},
+    {PAGE_SELECT_BYTE, SFF8636_EEPROM_BASE_PAGE, 127, 1},
+};
+
+static int sff8636_eeprom_load(void *busDrvPtr, int bus, uint8_t addr, uint8_t *data)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+
+    rv = eeprom_read_lowermap(i2c, bus, addr, data);
+    rv = eeprom_read_uppermap_by_page(i2c, bus, addr, SFF8636_EEPROM_PAGE0, data+SFP_EEPROM_PAGE_SIZE);
+   
+    return rv;
+}
+
+static int sff8636_eeprom_readb(void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint8_t *data)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+
+    rv = eeprom_readb(i2c, bus, addr, offset, 1, data);   
+
+    return rv;
+}
+
+static int sff8636_eeprom_writeb(void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint8_t data)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    
+    rv = eeprom_writeb(i2c, bus, addr, offset, 1, &data);
+    
+    return rv;
+}
+
+static int sff8636_control_is_support(int control, uint8_t *is_support)
+{
+    switch (control)
+    {
+        //case SFP_CONTROL_RESET:
+        case SFP_CONTROL_RESET_STATE:
+        case SFP_CONTROL_LP_MODE:
+        case SFP_CONTROL_RX_LOS:
+        case SFP_CONTROL_TX_FAULT:
+        case SFP_CONTROL_TX_DISABLE:
+        //case SFP_CONTROL_TX_DISABLE_CHANNEL:
+        //case SFP_CONTROL_POWER_OVERRIDE:
+            *is_support = CONTROL_IS_SUPPORT;
+            break;
+        default:
+            *is_support = CONTROL_IS_NOT_SUPPORT;
+            break;
+    }
+
+    return 0;
+}
+
+static int sff8636_control_get(
+    void *busDrvPtr, int bus, uint8_t addr,
+    int control,
+    int *status)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t *eeprom_data;
+    sff_field_t field = get_sff8636_control_field(control);
+    if(field == SFF_FIELD_MIN)
+    {
+        AIM_LOG_ERROR("VENDOR: The control type is not supported in SFF8636");
+        return -1;
+    }
+    sff8636_field_map_t *info = (sff8636_field_map_t *)calloc(1, sizeof(sff8636_field_map_t));
+
+    /* get the address of the control */
+    rv = get_sff8636_field(field, &info);
+    if(rv != 0) return rv;
+    eeprom_data = (uint8_t *)calloc(1, sizeof(uint8_t) * info->length);
+
+    /* get the control value from eeprom */
+    rv = get_sff8636_value_from_eeprom(i2c, bus, addr, info, eeprom_data);
+    if(rv != 0) return rv;
+    /* filter the right date which user need */
+    if(filter_sff8636_control_value_for_get(control, eeprom_data, status) != CONTROL_IS_SUPPORT) 
+    {
+        AIM_LOG_ERROR("VENDOR: The control type get status error in SFF8636");
+        return -1;        
+    }  
+    free(eeprom_data);
+    eeprom_data = NULL;
+    return rv;
+}
+
+static int sff8636_control_set(
+    void *busDrvPtr, int bus, uint8_t addr,
+    int control,
+    int status)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t *eeprom_data;
+    uint8_t value;
+    
+    if(control == SFP_CONTROL_RX_LOS || control == SFP_CONTROL_TX_FAULT)
+    {
+        AIM_LOG_ERROR("VENDOR: This control type is not writable in SFF8636");
+        return -1;
+    }
+
+    sff_field_t field = get_sff8636_control_field(control);
+    if(field == SFF_FIELD_MIN)
+    {
+        AIM_LOG_ERROR("VENDOR: This control type is not supported in SFF8636");
+        return -1;
+    }
+    
+    sff8636_field_map_t *info = (sff8636_field_map_t *)calloc(1, sizeof(sff8636_field_map_t));
+
+    /* get the address of the control */
+    rv = get_sff8636_field(field, &info);
+    if(rv != 0) return rv;
+
+    eeprom_data = (uint8_t *)calloc(1, sizeof(uint8_t) * info->length);
+    /* get the control value from eeprom */
+    rv = get_sff8636_value_from_eeprom(i2c, bus, addr, info, eeprom_data);
+
+    /* value check */
+    rv = filter_sff8636_control_value_for_set(control, eeprom_data, &status);
+    if(rv != 0) return rv;
+
+    /* set the control value to eeprom */
+    value = (uint8_t)status;
+    rv = set_sff8636_value_to_eeprom(i2c, bus, addr, info, &value);
+
+    free(eeprom_data);
+    eeprom_data = NULL;
+
+    return rv;
+}
+
+/*================ internal function ================*/
+
+static int get_sff8636_field(sff_field_t field, sff8636_field_map_t **info) {
+    
+    int i, cnt = sizeof(sff8636_field_map) / sizeof(sff8636_field_map_t);
+
+    if (field >= SFF_FIELD_MAX) {
+        return -1;
+    }
+
+    for (i = 0; i < cnt; i++) {
+        if (sff8636_field_map[i].field == field) {
+            *info = &(sff8636_field_map[i]);
+        }
+    }
+
+    if (!info)
+    {
+        AIM_LOG_ERROR("VENDOR: Cannot find sff8636 field!");
+        return -1;
+    } 
+
+    return 0;
+}
+
+static uint8_t get_sfp_flat_mem(i2c_bus_driver_t *i2c, int bus, uint8_t addr)
+{
+    int rv = 0;
+    uint8_t status[2];
+    uint8_t flat_mem = 0;
+    sff8636_field_map_t *info = (sff8636_field_map_t *)calloc(1, sizeof(sff8636_field_map_t));
+    
+    rv = get_sff8636_field(STATUS, &info);
+    if(rv != 0) return rv;
+    rv = eeprom_readb(i2c, bus, addr, info->offset, info->length, status);
+    if(rv != 0) return rv;
+
+    flat_mem = status[1] & (1 << 2);
+   
+    return flat_mem;
+}
+
+static int eeprom_read_lowermap(i2c_bus_driver_t *i2c, int bus, uint8_t addr, uint8_t *data)
+{
+    int rv = 0;
+    rv = smbus_block_read(bus, addr, 0, SFP_EEPROM_PAGE_SIZE, data);   
+   
+    return rv;
+}
+
+static int eeprom_uppermap_change_page(i2c_bus_driver_t *i2c, int bus, uint8_t addr, uint8_t page)
+{
+    int rv = 0;
+    if(!get_sfp_flat_mem(i2c, bus, addr)){
+        rv = eeprom_writeb(i2c, bus, addr, SFF8636_PAGE_CONTROL, 1, &page);
+    }
+       
+    return rv;
+}
+
+static int eeprom_read_uppermap_by_page(i2c_bus_driver_t *i2c, int bus, uint8_t addr, uint8_t page, uint8_t *data)
+{
+    int rv = 0;
+    
+    rv = eeprom_uppermap_change_page(i2c, bus, addr, page);   
+    rv = smbus_block_read(bus, addr, SFF8636_UPPER_PAGE_START_OFFSET, SFP_EEPROM_PAGE_SIZE, data);   
+   
+    return rv;
+}
+
+static int get_sff8636_value_from_eeprom(i2c_bus_driver_t *i2c, int bus, uint8_t addr, sff8636_field_map_t *info, uint8_t *value)
+{
+    int rv = 0;
+
+    rv = eeprom_uppermap_change_page(i2c, bus, addr, info->page);
+    if(rv != 0) return rv;
+
+    rv = eeprom_readb(i2c, bus, addr, info->offset, info->length, value);
+    if(rv != 0) return rv;
+
+    return rv;
+}
+
+static int set_sff8636_value_to_eeprom(i2c_bus_driver_t *i2c, int bus, uint8_t addr, sff8636_field_map_t *info, uint8_t *value)
+{
+    int rv = 0;
+
+    rv = eeprom_uppermap_change_page(i2c, bus, addr, info->page);
+    if(rv != 0) return rv;
+
+    rv = eeprom_writeb(i2c, bus, addr, info->offset, info->length, value);
+    if(rv != 0) return rv;
+
+    return rv;
+}
+
+static sff_field_t get_sff8636_control_field(int control)
+{
+    switch (control)
+    {
+        case SFP_CONTROL_RX_LOS:
+            return CHANNEL_LOS_INDICATOR;
+
+        case SFP_CONTROL_TX_FAULT:
+            return CHANNEL_TX_FAULT;
+
+        case SFP_CONTROL_TX_DISABLE:
+        case SFP_CONTROL_TX_DISABLE_CHANNEL:
+            return CHANNEL_TX_DISABLE;
+
+        case SFP_CONTROL_POWER_OVERRIDE:
+            return POWER_CONTROL;
+
+        case SFP_CONTROL_TEMPERATURE:
+            return TEMPERATURE;
+            
+        case SFP_CONTROL_VOLTAGE:
+            return VCC;
+
+        case SFP_CONTROL_TX_BIAS:
+            return CHANNEL_TX_BIAS;
+
+        case SFP_CONTROL_RX_POWER:
+            return CHANNEL_RX_PWR;
+
+        case SFP_CONTROL_TX_POWER:
+            return CHANNEL_TX_PWR;
+
+        default:
+            return SFF_FIELD_MIN;
+    }
+}
+
+/* SFP_CONTROL_RESET */                 /* SUPPORT_BY_CPLD */
+/* SFP_CONTROL_RESET_STATE */           /* SUPPORT_BY_CPLD */
+/* SFP_CONTROL_RX_LOS */                /* R 3.0 - 3.3 */
+/* SFP_CONTROL_TX_FAULT */              /* R 4.0 - 4.3 */
+/* SFP_CONTROL_TX_DISABLE */            /* RW 86.0 - 86.3 */
+/* SFP_CONTROL_TX_DISABLE_CHANNEL */    /* RW 86.0 - 86.3 */
+/* SFP_CONTROL_LP_MODE */               /* SUPPORT_BY_CPLD */
+/* SFP_CONTROL_POWER_OVERRIDE */        /* RW 93.0 POWER_OVERRIDE 
+                                         * RW 93.1 POWER_SET                                           
+                                         */
+
+static uint8_t filter_sff8636_control_value_for_get(
+    int control, 
+    uint8_t *eeprom_data, int *combined_data)
+{
+    int i = 0, j = 0;
+    uint8_t channel = 4;
+
+    switch (control)
+    {
+        case SFP_CONTROL_TX_DISABLE:
+        case SFP_CONTROL_TX_DISABLE_CHANNEL:
+            *combined_data = *eeprom_data & 0xf;
+            break;
+
+        case SFP_CONTROL_TX_FAULT:
+        case SFP_CONTROL_RX_LOS:    
+            for(i = 0; i < channel; i++)
+            { 
+                *(combined_data + i) = (*eeprom_data & (0x01 << i)) >> i ;                  
+            } 
+            break;
+
+        case SFP_CONTROL_POWER_OVERRIDE:
+            *combined_data = *eeprom_data & 0x3;
+            break;
+
+        case SFP_CONTROL_TEMPERATURE:/* Unit: Celsius */
+            *combined_data = (eeprom_data[0] << 8 | eeprom_data[1]) / 256;      
+            break;
+            
+        case SFP_CONTROL_VOLTAGE:/* Unit: mV */
+            *combined_data = (eeprom_data[0] << 8 | eeprom_data[1])  / 10;                
+            break;
+
+        case SFP_CONTROL_TX_BIAS:/* Unit: uA */
+            for(i = 0, j = 0 ; i < channel; i++, j=j+2)
+            {
+                *(combined_data + i) = (eeprom_data[j] << 8 | eeprom_data[j+1]) *2 ;                  
+            } 
+            break;
+
+        case SFP_CONTROL_RX_POWER:/* Unit: uW */
+            for(i = 0, j = 0; i < channel; i++, j=j+2)
+            {
+                *(combined_data + i) = (eeprom_data[j] << 8 | eeprom_data[j+1]) / 10;              
+            }
+            break;
+
+        case SFP_CONTROL_TX_POWER:/* Unit: uW */
+            for(i = 0, j = 0; i < channel; i++, j=j+2)
+            {
+                *(combined_data + i) = (eeprom_data[j] << 8 | eeprom_data[j+1]) / 10;              
+            }
+            break;
+
+        default:
+            return CONTROL_IS_NOT_SUPPORT;
+    }
+
+    return CONTROL_IS_SUPPORT;
+}
+
+#define SFP_CONTROL_POWER_OVERRIDE_MASK       0x3
+#define SFP_CONTROL_TX_DISABLE_CHANNEL_MASK   0xF
+
+static uint8_t filter_sff8636_control_value_for_set(
+    int control, 
+    uint8_t *eeprom_data,
+    int *write_status)
+{
+    int data;
+    int status=*write_status;
+    uint8_t curr_status = *eeprom_data;
+    switch (control)
+    {
+        case SFP_CONTROL_TX_DISABLE:
+            
+            if(status == 0 )
+            {
+                /*  clean mask bit value of current status */
+                data = curr_status & (~SFP_CONTROL_TX_DISABLE_CHANNEL_MASK);
+                *write_status = data;
+                return 0;
+            }
+            else if(status == 1 )
+            {
+                /*  clean mask bit of current status */
+                data = curr_status & (~SFP_CONTROL_TX_DISABLE_CHANNEL_MASK);
+                /*  calculate write data  */
+                data |= SFP_CONTROL_TX_DISABLE_CHANNEL_MASK;
+                *write_status = data;
+                return 0;
+            }
+            else
+            {
+                AIM_LOG_ERROR("VENDOR:\t[SFF8636] Status of TX disable should be 0 or 1 ");
+                return -1;
+            }
+
+        case SFP_CONTROL_TX_DISABLE_CHANNEL:
+            if(status >= 0 && status <= SFP_CONTROL_TX_DISABLE_CHANNEL_MASK)
+            {
+                /*  clean mask bit of current status */
+                data = curr_status & (~SFP_CONTROL_TX_DISABLE_CHANNEL_MASK);
+                /*  calculate write data  */
+                data |= (status & SFP_CONTROL_TX_DISABLE_CHANNEL_MASK);
+                *write_status = data;
+                return 0;
+            }
+            else
+            {
+                AIM_LOG_ERROR("VENDOR:\t[SFF8636] Status of TX disable channel should be 0 to 0xF ");
+                return -1;
+            }
+
+        case SFP_CONTROL_POWER_OVERRIDE:
+            if(status >= 0 && status <= SFP_CONTROL_POWER_OVERRIDE_MASK)
+            {
+                /*  clean mask bit of current status */
+                data = curr_status & (~SFP_CONTROL_POWER_OVERRIDE_MASK);
+                /*  calculate write data  */
+                data |= (status & SFP_CONTROL_POWER_OVERRIDE_MASK);
+                *write_status = data;
+                return 0;
+            }
+            else
+            {
+                AIM_LOG_ERROR("VENDOR:\t[SFF8636] Status of TX disable channel should be 0 to 0x3 ");
+                return -1;
+            }
+        default:
+            return CONTROL_IS_NOT_SUPPORT;
+    }
+}
+
+static sfp_dev_driver_t sff8636_functions = 
+{
+    sff8636_eeprom_load,
+    sff8636_eeprom_readb,
+    sff8636_eeprom_writeb,
+    sff8636_control_is_support,
+    sff8636_control_get,
+    sff8636_control_set
+};
+
+static int sff8636_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "SFF8636", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &sff8636_functions;
+    vendor_driver_add(driver);
+
+    driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+    strncpy(driver->name, "SFF8436", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &sff8636_functions;
+    vendor_driver_add(driver);
+    
+    return 0;
+}
+/*SFP DEVICE SFF8636 END*/
+
+/*SFP DEVICE SFF8472 START*/
+
+typedef enum
+{
+    SFF8472_EEPROM_ADDRESS_A0H = 0x50, 
+    SFF8472_EEPROM_ADDRESS_A2H = 0x51,
+
+}sff8472_address_t;
+
+typedef struct sff8472_field_map
+{
+    sff_field_t field;
+    uint8_t address;
+    uint16_t offset;
+    uint16_t length;
+}sff8472_field_map_t;
+
+static uint8_t filter_sff8472_control_value_for_get(int control, uint8_t *eeprom_data, int *combined_data);
+static uint8_t filter_sff8472_control_value_for_set(int control, uint8_t *eeprom_data, int *write_status);
+static sff_field_t get_sff8472_control_field(int control);
+static int get_sff8472_field(sff_field_t field, sff8472_field_map_t **info);
+static int get_sff8472_value_from_eeprom(i2c_bus_driver_t *i2c, int bus, uint8_t addr, sff8472_field_map_t *info, uint8_t *value);
+static int set_sff8472_value_to_eeprom(i2c_bus_driver_t *i2c, int bus, uint8_t addr, sff8472_field_map_t *info, uint8_t *value);
+static int check_sff8472_diagnostic_monitoring_type(void *busDrvPtr, int bus, uint8_t addr, uint8_t *type);
+
+static sff8472_field_map_t sff8472_field_map[] = {   
+    {IDENTIFIER, SFF8472_EEPROM_ADDRESS_A0H, 0, 1},
+    {DIAGNOSTIC_MONITORING_TYPE, SFF8472_EEPROM_ADDRESS_A0H, 92, 1},    
+    {EXTERNAL_CALIBRATION, SFF8472_EEPROM_ADDRESS_A2H, 56, 36},
+    {TEMPERATURE, SFF8472_EEPROM_ADDRESS_A2H, 96, 2},
+    {VCC, SFF8472_EEPROM_ADDRESS_A2H, 98, 2},
+    {CHANNEL_TX_BIAS, SFF8472_EEPROM_ADDRESS_A2H, 100, 2},
+    {CHANNEL_TX_PWR, SFF8472_EEPROM_ADDRESS_A2H, 102, 2},
+    {CHANNEL_RX_PWR, SFF8472_EEPROM_ADDRESS_A2H, 104, 2},
+    {CHANNEL_LOS_INDICATOR, SFF8472_EEPROM_ADDRESS_A2H, 110, 1},
+    {CHANNEL_TX_FAULT, SFF8472_EEPROM_ADDRESS_A2H, 110, 1},
+    {CHANNEL_TX_DISABLE, SFF8472_EEPROM_ADDRESS_A2H, 110, 1},
+};
+
+static int sff8472_eeprom_load(void *busDrvPtr, int bus, uint8_t addr, uint8_t *data)
+{
+    int rv = 0;
+
+    rv = smbus_block_read(bus, addr, 0, SFP_EEPROM_SIZE, data); 
+   
+    return rv;
+}
+
+/*static int sff8472_dom_eeprom_load(i2c_bus_driver_t *i2c, int bus, uint8_t addr, uint8_t *data)
+{
+    int rv = 0;
+
+    rv = smbus_block_read(bus, SFF8472_EEPROM_ADDRESS_A2H, 0, SFP_EEPROM_SIZE, data); 
+   
+    return rv;
+}
+*/
+static int sff8472_eeprom_readb(void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint8_t *data)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+
+    rv = eeprom_readb(i2c, bus, addr, offset, 1, data);   
+
+    return rv;
+}
+
+static int sff8472_eeprom_writeb(void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint8_t data)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    
+    rv = eeprom_writeb(i2c, bus, addr, offset, 1, &data);
+    
+    return rv;
+}
+
+static int sff8472_control_is_support(int control, uint8_t *is_support)
+{
+    switch (control)
+    {
+        case SFP_CONTROL_RX_LOS:
+        case SFP_CONTROL_TX_FAULT:
+        case SFP_CONTROL_TX_DISABLE:
+        case SFP_CONTROL_TEMPERATURE:
+        case SFP_CONTROL_VOLTAGE:
+        case SFP_CONTROL_TX_BIAS:
+        case SFP_CONTROL_RX_POWER:
+        case SFP_CONTROL_TX_POWER:
+            *is_support = CONTROL_IS_SUPPORT;
+            break;
+        case SFP_CONTROL_RESET:
+        case SFP_CONTROL_RESET_STATE:
+        case SFP_CONTROL_LP_MODE:
+        case SFP_CONTROL_TX_DISABLE_CHANNEL:
+        case SFP_CONTROL_POWER_OVERRIDE:
+            *is_support = CONTROL_IS_NOT_SUPPORT;
+            break;
+        default:
+            *is_support = CONTROL_IS_NOT_SUPPORT;
+            break;
+    }
+
+    return 0;
+}
+
+static int check_sff8472_diagnostic_monitoring_type(void *busDrvPtr, int bus, uint8_t addr, uint8_t *type)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t data;
+
+    sff8472_field_map_t *info = (sff8472_field_map_t *)calloc(1, sizeof(sff8472_field_map_t));
+
+    rv = get_sff8472_field(DIAGNOSTIC_MONITORING_TYPE, &info);
+    if(rv != 0) return rv;
+
+    rv = eeprom_readb(i2c, bus, addr, info->offset, info->length, &data);
+    if(rv != 0) return rv;
+
+    *type = (data >> 5) & 0x01;  
+
+    return rv;
+}
+
+static int sff8472_control_get(
+    void *busDrvPtr, int bus, uint8_t addr,
+    int control,
+    int *status)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t *eeprom_data;
+    uint8_t type;
+    sff_field_t field = get_sff8472_control_field(control);
+    if(field == SFF_FIELD_MIN)
+    {
+        AIM_LOG_ERROR("VENDOR: The control type is not supported in SFF8472");
+        return -1;
+    }
+    
+    sff8472_field_map_t *info = (sff8472_field_map_t *)calloc(1, sizeof(sff8472_field_map_t));
+
+    rv = get_sff8472_field(field, &info);
+    if(rv != 0) return rv;
+
+    eeprom_data = (uint8_t *)calloc(1, sizeof(uint8_t) * info->length);
+
+
+    /* get the control value from eeprom */
+    rv = get_sff8472_value_from_eeprom(i2c, bus, addr, info, eeprom_data);
+    if(rv != 0) return rv;
+
+    if(check_sff8472_diagnostic_monitoring_type(i2c, bus, addr, &type) == 0)
+    {   
+
+        if(!type)
+        {
+            /*TODO*/
+            AIM_LOG_ERROR("VENDOR: External calibration not yet supported.");
+            return -1; 
+
+        }
+        else
+        {
+            /* filter the right date which user need */
+            if(filter_sff8472_control_value_for_get(control, eeprom_data, status) != CONTROL_IS_SUPPORT) 
+            {
+                AIM_LOG_ERROR("VENDOR: The control type get status error in SFF8472");
+                return -1;        
+            } 
+        }
+    }
+    else
+    {
+        AIM_LOG_ERROR("VENDOR: The control type get diagnostic monitoring type error in SFF8472");
+        return -1;
+
+    }
+ 
+    free(eeprom_data);
+    eeprom_data = NULL;
+
+    return rv;
+}
+
+static int sff8472_control_set(
+    void *busDrvPtr, int bus, uint8_t addr,
+    int control,
+    int status)
+{
+    i2c_bus_driver_t *i2c = (i2c_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    uint8_t *eeprom_data;
+    uint8_t value;
+    
+    if(control != SFP_CONTROL_TX_DISABLE)
+    {
+        AIM_LOG_ERROR("VENDOR: This control type is not writable in SFF8472");
+        return -1;
+    }
+
+    sff_field_t field = get_sff8472_control_field(control);
+    if(field == SFF_FIELD_MIN)
+    {
+        AIM_LOG_ERROR("VENDOR: This control type is not supported in SFF8472");
+        return -1;
+    }
+    
+    sff8472_field_map_t *info = (sff8472_field_map_t *)calloc(1, sizeof(sff8472_field_map_t));
+
+    rv = get_sff8472_field(field, &info);
+    if(rv != 0) return rv;
+
+    eeprom_data = (uint8_t *)calloc(1, sizeof(uint8_t) * info->length);
+    /* get the control value from eeprom */
+    rv = get_sff8472_value_from_eeprom(i2c, bus, addr, info, eeprom_data);
+
+    /* value check */
+    rv = filter_sff8472_control_value_for_set(control, eeprom_data, &status);
+    if(rv != 0) return rv;
+
+    /* set the control value to eeprom */
+    value = (uint8_t)status;
+    rv = set_sff8472_value_to_eeprom(i2c, bus, addr, info, &value);
+
+    free(eeprom_data);
+    eeprom_data = NULL;
+
+    return rv;
+}
+
+/*================ internal function ================*/
+
+static int get_sff8472_field(sff_field_t field, sff8472_field_map_t **info) {
+    
+    int i, cnt = sizeof(sff8472_field_map) / sizeof(sff8472_field_map_t);
+
+    if (field >= SFF_FIELD_MAX) {
+        return -1;
+    }
+
+    for (i = 0; i < cnt; i++) {
+        if (sff8472_field_map[i].field == field) {
+            *info = &(sff8472_field_map[i]);
+        }
+    }
+
+    if (!info){
+        AIM_LOG_ERROR("VENDOR: Cannot find sff8472 field!");
+        return -1;
+    } 
+
+    return 0;
+}
+
+static int get_sff8472_value_from_eeprom(i2c_bus_driver_t *i2c, int bus, uint8_t addr, sff8472_field_map_t *info, uint8_t *value)
+{
+    int rv = 0;
+
+    rv = eeprom_readb(i2c, bus, info->address, info->offset, info->length, value);
+
+    return rv;
+}
+
+static int set_sff8472_value_to_eeprom(i2c_bus_driver_t *i2c, int bus, uint8_t addr, sff8472_field_map_t *info, uint8_t *value)
+{
+    int rv = 0;
+
+    rv = eeprom_writeb(i2c, bus, info->address, info->offset, info->length, value);
+
+    return rv;
+}
+
+static sff_field_t get_sff8472_control_field(int control)
+{
+    switch (control)
+    {
+        case SFP_CONTROL_RX_LOS:
+            return CHANNEL_LOS_INDICATOR;
+
+        case SFP_CONTROL_TX_FAULT:
+            return CHANNEL_TX_FAULT;
+
+        case SFP_CONTROL_TX_DISABLE:
+            return CHANNEL_TX_DISABLE;
+
+        case SFP_CONTROL_TEMPERATURE:
+            return TEMPERATURE;
+            
+        case SFP_CONTROL_VOLTAGE:
+            return VCC;
+
+        case SFP_CONTROL_TX_BIAS:
+            return CHANNEL_TX_BIAS;
+
+        case SFP_CONTROL_RX_POWER:
+            return CHANNEL_RX_PWR;
+
+        case SFP_CONTROL_TX_POWER:
+            return CHANNEL_TX_PWR;
+
+        default:
+            return SFF_FIELD_MIN;
+    }
+}
+
+/* SFP_CONTROL_RESET */ /* SUPPORT_BY_CPLD */
+/* SFP_CONTROL_RESET_STATE */ /* SUPPORT_BY_CPLD */
+/* SFP_CONTROL_RX_LOS */ /*R 3.0 - 3.3 */
+/* SFP_CONTROL_TX_FAULT */ /*R 4.0 - 4.3 */
+/* SFP_CONTROL_TX_DISABLE */ /*RW 86.0 - 86.3 */
+/* SFP_CONTROL_TX_DISABLE_CHANNEL */
+/* SFP_CONTROL_LP_MODE */ /* SUPPORT_BY_CPLD */
+/* SFP_CONTROL_POWER_OVERRIDE, */ /*RW 93.0 */
+
+static uint8_t filter_sff8472_control_value_for_get(
+    int control, 
+    uint8_t *eeprom_data, int *combined_data)
+{
+    switch (control)
+    {
+        case SFP_CONTROL_TX_DISABLE:
+            *combined_data = *eeprom_data & 0x40 ? 0x1 : 0x0;
+            break;
+        
+        case SFP_CONTROL_RX_LOS:
+            *combined_data = *eeprom_data & 0x02 ? 0x1 : 0x0;
+            break;
+
+        case SFP_CONTROL_TX_FAULT:
+            *combined_data = *eeprom_data & 0x4 ? 0x1 : 0x0;
+            break;
+
+        case SFP_CONTROL_TEMPERATURE:/* Unit: Celsius */
+            *combined_data = (eeprom_data[0] << 8 | eeprom_data[1]) / 256;      
+            break;
+            
+        case SFP_CONTROL_VOLTAGE:/* Unit: mV */
+            *combined_data = (eeprom_data[0] << 8 | eeprom_data[1]) / 10;                
+            break;
+
+        case SFP_CONTROL_TX_BIAS:/* Unit: uA */
+            *combined_data = (eeprom_data[0] << 8 | eeprom_data[1]) * 2 ;                   
+            break;
+
+        case SFP_CONTROL_RX_POWER:/* Unit: uW */
+            *combined_data = (eeprom_data[0] << 8 | eeprom_data[1]) / 10;             
+            break;
+
+        case SFP_CONTROL_TX_POWER:/* Unit: uW */
+                *combined_data = (eeprom_data[0] << 8 | eeprom_data[1]) / 10;         
+            break;
+
+        default:
+            return CONTROL_IS_NOT_SUPPORT;
+    }
+
+    return CONTROL_IS_SUPPORT;
+
+}
+
+static uint8_t filter_sff8472_control_value_for_set(
+    int control, 
+    uint8_t *eeprom_data, 
+    int *write_status)
+{
+    int status=*write_status;
+    uint8_t curr_status = *eeprom_data;
+    switch (control)
+    {
+        case SFP_CONTROL_TX_DISABLE:
+        if(status == 0 )
+        {
+            *write_status = curr_status & ~0x40;
+             return 0;
+        }
+        else if(status == 1 )
+        {
+            *write_status = curr_status & ~0x40;
+            *write_status |= 0x40;
+             return 0;
+        }
+        else
+        {
+            AIM_LOG_ERROR("VENDOR:\t[SFF8472] Status of TX disable should be 0 or 1 ");
+            return -1;
+        }
+
+        default:
+            return CONTROL_IS_NOT_SUPPORT;
+    }
+}
+
+static sfp_dev_driver_t sff8472_functions = 
+{
+    sff8472_eeprom_load,
+    sff8472_eeprom_readb,
+    sff8472_eeprom_writeb,
+    sff8472_control_is_support,
+    sff8472_control_get,
+    sff8472_control_set
+};
+
+static int sff8472_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "SFF8472", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &sff8472_functions;
+    vendor_driver_add(driver);
+    
+    return 0;
+}
+/*SFP DEVICE SFF8472 END*/
+
+/*BMC DEVICE START*/
+
+typedef enum bmc_command
+{
+    BMC_CMD_PSU_GET_PRESENT = 0,
+    BMC_CMD_PSU_GET_POWER_GOOD,
+    BMC_CMD_PSU_GET_MODEL_NAME,
+    BMC_CMD_PSU_GET_SERIAL_NUM,
+    BMC_CMD_PSU_GET_VOLTAGE,
+    BMC_CMD_PSU_GET_CURRENT,
+    BMC_CMD_FAN_GET_PRESENT,
+    BMC_CMD_FAN_GET_RPM,
+    BMC_CMD_THERMAL_GET_TEMP,
+    BMC_CMD_MAX
+} bmc_command_t;
+
+typedef enum bmc_command_type
+{
+    BMC_CMD_TYPE_NONE = 0,
+    BMC_CMD_TYPE_STANDARD,
+    BMC_CMD_TYPE_RAW
+} bmc_command_type_t;
+
+typedef struct bmc_ipmi_command_info_s
+{
+    bmc_command_t       command;
+    bmc_command_type_t  command_type;
+    char               *cmd;
+    char               *filter;
+} bmc_ipmi_command_info_t;
+
+/*
+ *  The command array MUST 1-to-1 map to bmc_command_t
+ */
+static bmc_ipmi_command_info_t bmc_ipmi_command_info[] = 
+{
+    {
+        BMC_CMD_PSU_GET_PRESENT,
+        BMC_CMD_TYPE_STANDARD,
+        "fru print %s 2>/dev/null",
+        "|grep \"Product Name\" |cut -d : -f 2 |cut -d ' ' -f 2-"
+    },
+    {
+        BMC_CMD_PSU_GET_POWER_GOOD,
+        BMC_CMD_TYPE_NONE,
+        NULL,
+        NULL
+    },
+    {
+        BMC_CMD_PSU_GET_MODEL_NAME,
+        BMC_CMD_TYPE_STANDARD,
+        "fru print %s",
+        "|grep \"Product Name\" |cut -d : -f 2 |cut -d ' ' -f 2-"
+    },
+    {
+        BMC_CMD_PSU_GET_SERIAL_NUM,
+        BMC_CMD_TYPE_STANDARD,
+        "fru print %s",
+        "|grep \"Product Serial\" |cut -d : -f 2 |cut -d ' ' -f 2-"
+    },
+    {
+        BMC_CMD_PSU_GET_VOLTAGE,
+        BMC_CMD_TYPE_RAW,
+        "raw 0x3C 0xE0 0x11 %s 0x8B",
+        ""
+    },
+    {
+        BMC_CMD_PSU_GET_CURRENT,
+        BMC_CMD_TYPE_RAW,
+        "raw 0x3C 0xE0 0x11 %s 0x8C",
+        ""
+    },
+
+    {
+        BMC_CMD_FAN_GET_PRESENT,
+        BMC_CMD_TYPE_RAW,
+        "raw 0x3C 0xE0 0x05 %s 0x00",
+        ""
+    },
+    {
+        BMC_CMD_FAN_GET_RPM,
+        BMC_CMD_TYPE_STANDARD,
+        "sensor get %s",
+        "|grep \"Sensor Reading\" |cut -d : -f 2 |cut -d ' ' -f 2"
+    },
+
+    {
+        BMC_CMD_THERMAL_GET_TEMP,
+        BMC_CMD_TYPE_STANDARD,
+        "sensor get %s",
+        "|grep \"Sensor Reading\" |cut -d : -f 2 |cut -d ' ' -f 2"
+    }
+};
+
+static char *ipmi_psu_std_unit_id[] =
+{
+    "1",
+    "2"
+};
+
+static char *ipmi_psu_raw_unit_id[] =
+{
+    "0",
+    "1"
+};
+
+static char *ipmi_fan_std_unit_id[] =
+{
+    "FanPWM_0",
+    "FanPWM_0_1",
+    "FanPWM_1",
+    "FanPWM_1_1",
+    "FanPWM_2",
+    "FanPWM_2_1",
+    "FanPWM_3",
+    "FanPWM_3_1"
+};
+
+static char *ipmi_fan_raw_unit_id[] =
+{
+    "0",
+    "0",
+    "1",
+    "1",
+    "2",
+    "2",
+    "3",
+    "3"
+};
+
+static char *ipmi_thrml_unit_id[] =
+{
+    "Temp_L0",
+    "Temp_L1",
+    "Temp_L2",
+    "Temp_L3"
+};
+
+static int bmc_addr_get_device_type(uint8_t addr)
+{
+    return addr >> 6;
+}
+
+static int bmc_addr_get_id(uint8_t addr)
+{
+    return addr & 0x3f;
+}
+
+static bmc_ipmi_command_info_t *get_bmc_command_info(bmc_command_t command)
+{
+    int i;
+
+    for (i = 0; i < BMC_CMD_MAX; i++) {
+        if (bmc_ipmi_command_info[i].command == command)
+            return &bmc_ipmi_command_info[i];
+    }
+
+    return NULL;
+}
+
+//OK
+static char *get_bmc_command_unit_id(int deviceType, int unit, bmc_ipmi_command_info_t *info)
+{
+    char *unit_id_str = NULL;
+
+    if (deviceType == VENDOR_PSU)
+    {
+        if (info->command_type == BMC_CMD_TYPE_STANDARD)
+            unit_id_str = ipmi_psu_std_unit_id[unit];
+        else if (info->command_type == BMC_CMD_TYPE_RAW)
+            unit_id_str = ipmi_psu_raw_unit_id[unit];
+    }
+    else if (deviceType == VENDOR_FAN)
+    {
+        if (info->command_type == BMC_CMD_TYPE_STANDARD)
+            unit_id_str = ipmi_fan_std_unit_id[unit];
+        else if (info->command_type == BMC_CMD_TYPE_RAW)
+            unit_id_str = ipmi_fan_raw_unit_id[unit];
+    }
+    else if (deviceType == VENDOR_TEMPERATURE)
+    {
+        unit_id_str = ipmi_thrml_unit_id[unit];
+    }
+    else if (deviceType == VENDOR_PSU_PRESENT)
+    {
+        if (info->command_type == BMC_CMD_TYPE_STANDARD)
+            unit_id_str = ipmi_psu_std_unit_id[unit];
+        else if (info->command_type == BMC_CMD_TYPE_RAW)
+            unit_id_str = ipmi_psu_raw_unit_id[unit];
+    }
+    else if (deviceType == VENDOR_FAN_PRESENT)
+    {
+        if (info->command_type == BMC_CMD_TYPE_STANDARD)
+            unit_id_str = ipmi_fan_std_unit_id[unit];
+        else if (info->command_type == BMC_CMD_TYPE_RAW)
+            unit_id_str = ipmi_fan_raw_unit_id[unit];
+    }
+
+    return unit_id_str;
+}
+
+//OK
+static int bmc_raw_data_process(char *bmcData)
+{
+    uint32_t result, value[4];
+
+    if ((sscanf(bmcData, " %02X %02X %02X %02X %02X", &result,
+                    &value[0], &value[1], &value[2], &value[3]) != 5) ||
+        (result != 0))
+    {
+        return 0;
+    }
+    else
+    {
+        result = (value[0] & 0xff);
+        result |= ((value[1] & 0xff) << 8);
+        result |= ((value[2] & 0xff) << 16);
+        result |= ((value[3] & 0xff) << 24);
+        sprintf(bmcData, "%u", result);
+
+        return 0;
+    }
+}
+
+static int _bmc_data_get(
+    ipmi_bus_driver_t *ipmi,
+    int deviceType,
+    int id,
+    int bus,
+    void *command_info,
+    char *bmcData,
+    int dataLen)
+{
+    int rv = 0;
+
+    if (!command_info || !bmcData) return 0;
+
+    bmc_ipmi_command_info_t *info = NULL;
+    char *unit_id_str = NULL;
+    char  cmd[32] = {0};
+
+    info = (bmc_ipmi_command_info_t *)command_info;
+    if (!info->cmd || !info->filter) return 0;
+
+    if ((unit_id_str = get_bmc_command_unit_id(deviceType, id, info)) == NULL)
+    {
+        AIM_LOG_ERROR("Can't get unit id for deviceType %d!", deviceType);
+        return 0;
+    }
+    sprintf(cmd, info->cmd, unit_id_str);
+
+    rv = ipmi->get(bus,
+                cmd,
+                info->filter,
+                bmcData,
+                dataLen);
+    //AIM_LOG_ERROR("Issue ipmitool %s %s => %s", cmd, info->filter, bmcData);
+
+    if ((rv == 0) && (info->command_type == BMC_CMD_TYPE_RAW))
+        rv = bmc_raw_data_process(bmcData);
+
+    return rv;
+}
+
+int bmc_data_get(
+    ipmi_bus_driver_t *ipmi,
+    int deviceType,
+    int id,
+    int bus,
+    bmc_command_t command,
+    char *bmcData,
+    int dataLen)
+{
+    void   *info = NULL;
+
+    info = get_bmc_command_info(command);
+    return _bmc_data_get(ipmi, deviceType, id, bus, info, bmcData, dataLen);
+}
+
+static int bmc_psu_model_get( 
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    char *model)
+{
+    ipmi_bus_driver_t *ipmi = (ipmi_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    char buf[256] = {0};
+    int len = 0;
+    int deviceType = bmc_addr_get_device_type(addr);
+    int id = bmc_addr_get_id(addr);
+
+    if (!model) return 0;
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, BMC_CMD_PSU_GET_MODEL_NAME, buf, sizeof(buf))) == 0)
+    {
+        len = strlen(buf);
+        if (buf[len-1] == '\n')
+        {
+            buf[len-1] = '\0';
+            len--;
+        }
+        strcpy(model, buf);
+    }
+
+    return rv;
+}
+
+static int bmc_psu_serial_get(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    char *serial)
+{
+    ipmi_bus_driver_t *ipmi = (ipmi_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    char buf[256] = {0};
+    int len = 0;
+    int deviceType = bmc_addr_get_device_type(addr);
+    int id = bmc_addr_get_id(addr);
+
+    if (!serial) return 0;
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, BMC_CMD_PSU_GET_SERIAL_NUM, buf, sizeof(buf))) == 0)
+    {
+        len = strlen(buf);
+        if (buf[len-1] == '\n')
+        {
+            buf[len-1] = '\0';
+            len--;
+        }
+        strcpy(serial, buf);
+    }
+
+    return rv;
+}
+
+static int bmc_psu_volt_get(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    int *volt)
+{
+    ipmi_bus_driver_t *ipmi = (ipmi_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    char buf[256] = {0};
+    int deviceType = bmc_addr_get_device_type(addr);
+    int id = bmc_addr_get_id(addr);
+
+    if (!volt) return 0;
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, BMC_CMD_PSU_GET_VOLTAGE, buf, sizeof(buf))) == 0)
+    {
+        *volt = atoi(buf);
+    }
+
+    return rv;
+}
+
+static int bmc_psu_amp_get(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    int *amp)
+{
+    ipmi_bus_driver_t *ipmi = (ipmi_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    char buf[256] = {0};
+    int deviceType = bmc_addr_get_device_type(addr);
+    int id = bmc_addr_get_id(addr);
+
+    if (!amp) return 0;
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, BMC_CMD_PSU_GET_CURRENT, buf, sizeof(buf))) == 0)
+    {
+        *amp = atoi(buf);
+    }
+
+    return rv;
+}
+
+static int bmc_psu_watt_get(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    int *watt)
+{
+    ipmi_bus_driver_t *ipmi = (ipmi_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    char buf[256] = {0};
+    int deviceType = bmc_addr_get_device_type(addr);
+    int id = bmc_addr_get_id(addr);
+
+    if (!watt) return 0;
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, BMC_CMD_PSU_GET_VOLTAGE, buf, sizeof(buf))) == 0)
+    {
+        *watt = atoi(buf);
+    }
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, BMC_CMD_PSU_GET_CURRENT, buf, sizeof(buf))) == 0)
+    {
+        *watt *= atoi(buf);
+        *watt /= 1000;
+    }
+
+    return rv;
+}
+
+static int bmc_fan_rpm_get(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    int noused,
+    int *rpm)
+{
+    ipmi_bus_driver_t *ipmi = (ipmi_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    char buf[256] = {0};
+    int deviceType = bmc_addr_get_device_type(addr);
+    int id = bmc_addr_get_id(addr);
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, BMC_CMD_FAN_GET_RPM, buf, sizeof(buf))) == 0)
+    {
+        *rpm = (uint16_t)atoi(buf);
+    }
+
+    return rv;
+}
+
+static int bmc_fan_rpm_set(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    int noused,
+    int rpm)
+{
+    int rv = 0;
+    AIM_LOG_ERROR("It is not supported in BMC.");
+    return rv;
+}
+
+static int bmc_thrml_temp_get(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    int noused,
+    int *temperature)
+{
+    ipmi_bus_driver_t *ipmi = (ipmi_bus_driver_t *)busDrvPtr;
+    int rv = 0;
+    char buf[256] = {0};
+    int deviceType = bmc_addr_get_device_type(addr);
+    int id = bmc_addr_get_id(addr);
+
+    if (!temperature) return 0;
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, BMC_CMD_THERMAL_GET_TEMP, buf, sizeof(buf))) == 0)
+    {
+        *temperature = atoi(buf) * 1000;
+    }
+
+    return rv;
+}
+
+static int bmc_thrml_limit_get(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    int noused,
+    int type, 
+    int *temperature)
+{
+    return 0;
+}
+
+static int bmc_thrml_limit_set(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    int noused,
+    int type, 
+    int temperature)
+{
+    return 0;
+}
+static int bmc_present_get(
+    void *busDrvPtr,
+    int bus,
+    uint8_t addr,
+    uint8_t offset,
+    uint8_t *present)
+{
+    ipmi_bus_driver_t *ipmi = (ipmi_bus_driver_t *)busDrvPtr;
+    bmc_command_t       command;
+    int rv = 0;
+    char buf[256] = {0};
+    int deviceType = bmc_addr_get_device_type(addr);
+    int id = bmc_addr_get_id(addr);
+
+    if (!present) return 0;
+
+    if (deviceType == VENDOR_PSU_PRESENT)
+        command = BMC_CMD_PSU_GET_PRESENT;
+    else if (deviceType == VENDOR_FAN_PRESENT)
+        command = BMC_CMD_FAN_GET_PRESENT;
+    else
+    {
+        AIM_LOG_ERROR("Unknown BMC deviceType: %d!", deviceType);
+        return 0;
+    }
+
+    if ((rv = bmc_data_get(ipmi, deviceType, id,  bus, command, buf, sizeof(buf))) == 0)
+    {
+        if (buf[0] == '\0')
+            *present = 0;
+        else
+        {
+            if ((command == BMC_CMD_FAN_GET_PRESENT) && !atoi(buf))
+                *present = 0;
+            else
+                *present = 1;
+        }
+    }
+
+    return rv;
+}
+
+static psu_dev_driver_t bmc_psu_functions =
+{
+    bmc_psu_model_get,
+    bmc_psu_serial_get,
+    bmc_psu_volt_get,
+    bmc_psu_amp_get,
+    bmc_psu_watt_get
+};
+
+static fan_dev_driver_t bmc_fan_functions = 
+{
+    bmc_fan_rpm_get,
+    bmc_fan_rpm_set,
+};
+
+static thermal_dev_driver_t bmc_thrml_functions =
+{
+    bmc_thrml_temp_get,
+    bmc_thrml_limit_get,
+    bmc_thrml_limit_set
+};
+
+static present_get_driver_t bmc_stat_functions =
+{
+    bmc_present_get
+};
+
+int bmc_psu_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "BMC_PSU", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &bmc_psu_functions;
+
+    return vendor_driver_add(driver);
+}
+
+int bmc_fan_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "BMC_FAN", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &bmc_fan_functions;
+
+    return vendor_driver_add(driver);
+}
+
+int bmc_thrml_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "BMC_TMP", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &bmc_thrml_functions;
+
+    return vendor_driver_add(driver);
+}
+
+int bmc_present_get_driver_init()
+{
+    vendor_driver_t *driver = (vendor_driver_t *)calloc(1, sizeof(vendor_driver_t));
+
+    strncpy(driver->name, "BMC_STAT", VENDOR_MAX_NAME_SIZE);
+    driver->dev_driver = &bmc_stat_functions;
+
+    return vendor_driver_add(driver); 
+}
+/*BMC DEVICE END*/
+
+/*
+    DEVICE DRIVER END:
+*/
+
+/*
+    VENDOR FUNCTION START
+*/
+
+static vendor_driver_node_t *driver_list_head, *driver_list_curr;
+
+static int vendor_driver_add(vendor_driver_t *driver)
+{
+    vendor_driver_node_t *newnode = 
+        (vendor_driver_node_t *) calloc(1, sizeof(vendor_driver_node_t));
+    
+    newnode->driver_hdl = driver;
+
+    if(!driver_list_head)
+    {
+        driver_list_head = driver_list_curr = newnode;
+    }
+    else
+    {
+        driver_list_curr->node = newnode;
+        driver_list_curr = newnode;
+    }
+
+    return 0;
+}
+
+void *vendor_find_driver_by_name(const char *driver_name)
+{
+    vendor_driver_node_t *driver_node = driver_list_head;
+
+    while(driver_node)
+    {
+        if (strncmp(
+            ((vendor_driver_t *)((vendor_driver_node_t *)driver_node->driver_hdl))->name, 
+            driver_name, 
+            VENDOR_MAX_NAME_SIZE) == 0)
+        {
+            return (void *) (driver_node->driver_hdl->dev_driver);
+        }
+        driver_node = driver_node->node;
+    }
+
+    AIM_LOG_ERROR("Function: %s, Cannot find driver %s.", __FUNCTION__, driver_name);
+
+    return NULL;
+}
+
+int vendor_find_copper_by_name(const char *dev_name)
+{
+
+    if (strncmp(dev_name, "copper", VENDOR_MAX_NAME_SIZE) == 0)
+        return 1;
+    else
+        return 0;
+}
+
+int vendor_driver_init()
+{
+    smbus_driver_init();
+    ipmi_driver_init();
+    cpld_driver_init();
+    eeprom_driver_init();
+    emc2305_driver_init();
+    tmp75_driver_init();
+    tmp461_driver_init();
+    pmbus_psu_driver_init();
+    pmbus_fan_driver_init();
+    sff8636_driver_init();
+    sff8472_driver_init();
+    ipmb_driver_init();
+    bmc_psu_driver_init();
+    bmc_fan_driver_init();
+    bmc_thrml_driver_init();
+    bmc_present_get_driver_init();
+
+    return 0;
+}
+
+int vendor_dev_do_oc(vendor_dev_oc_t *dev_oc)
+{
+    //AIM_LOG_ERROR("Function: %s", __FUNCTION__);
+    int rv = 0;
+
+    if(dev_oc == NULL)
+    {
+        /*NO NEED */
+        return rv;
+    }
+
+    while (dev_oc->type != 0)
+    {
+        if(dev_oc->type == 1)
+        {
+            rv = smbus_writeb(dev_oc->bus, dev_oc->addr, dev_oc->offset, dev_oc->value);
+        }
+        else if (dev_oc->type == 2)
+        {
+            rv = smbus_readb(dev_oc->bus, dev_oc->addr, dev_oc->offset);
+            if(rv < 0) return rv;
+
+            rv &= ~dev_oc->mask;
+            rv |= (dev_oc->match & dev_oc->mask);
+
+            rv = smbus_writeb(dev_oc->bus, dev_oc->addr, dev_oc->offset, rv);
+        }
+        else
+        {
+            AIM_LOG_ERROR("Function: %s, unknown oc type. \n", __FUNCTION__);
+            rv = -1;
+        }
+        
+        if(rv < 0) return rv;
+        
+        dev_oc++;
+    }
+
+    return rv;
+}
+
+int vendor_find_cpld_idx(uint8_t addr)
+{
+    int idx = 0;
+
+    while(idx < cpld_list_size)
+    {
+        if(cpld_dev_list[idx].addr == addr) return idx;
+        idx++;
+    }
+
+    AIM_LOG_ERROR("Function: %s, Cannot find CPLD index.", __FUNCTION__);
+    return -1;
+}
+
+int vendor_get_present_status(vendor_dev_io_pin_t *present_info, int *present)
+{
+    int rv = 0, cpld_idx = 0;
+    void *busDrv = NULL;
+    present_get_driver_t *pg = NULL;
+    uint8_t bus, addr, offset;
+    
+
+    if(present_info->type == CPLD_DEV)
+    {
+        if(present_info->addr == 0)
+        {
+            *present = 1;
+            return 0;
+        }
+
+        bus    = present_info->bus;
+        addr   = present_info->addr & 0x7f;
+        offset = present_info->offset;
+
+        busDrv = (void *)vendor_find_driver_by_name("I2C");
+        pg = (present_get_driver_t *) vendor_find_driver_by_name("CPLD");
+
+        cpld_idx = vendor_find_cpld_idx(present_info->addr);
+        if(cpld_idx < 0) return ONLP_STATUS_E_INTERNAL;
+
+        vendor_dev_do_oc(cpld_o_list[cpld_idx]);
+    }
+    else if(present_info->type == BMC_DEV)
+    {
+        bus    = present_info->bus;
+        addr   = present_info->addr;
+        offset = present_info->offset;
+
+        busDrv = (void *)vendor_find_driver_by_name("IPMI");
+        pg = (present_get_driver_t *) vendor_find_driver_by_name("BMC_STAT");
+    }
+    else
+    {
+        AIM_LOG_ERROR("Unknow PRESENT TYPE.");
+        return -1;
+    }
+
+    rv = pg->present_get(
+            busDrv,
+            bus,
+            addr,
+            offset,
+            (uint8_t *) present);
+
+    if(present_info->type == CPLD_DEV)
+    {
+        vendor_dev_do_oc(cpld_c_list[cpld_idx]);
+        *present = ((rv & present_info->mask) == present_info->match) ? 1 : 0;
+    }
+
+    return rv;
+}
+
+int vendor_system_call_get(char *cmd, char *data)
+{
+    FILE *fp;
+    char buf[256] = {0};
+    int c;
+
+    fp = popen(cmd,"r");
+    if(!fp)
+        return -1;
+
+    while(fread(buf, sizeof(buf), 1, fp))
+        while ((c = getchar()) != EOF)
+            printf("output = %s", buf);
+
+    memcpy(data, buf, sizeof(buf));
+
+    return WEXITSTATUS(pclose(fp));
+}
+
+int vendor_system_call_set(char *cmd)
+{
+    return system(cmd);
+}
+
+/*
+    VENDOR DRIVER FUNCTION END
+*/
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_driver_pool.h ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_driver_pool.h
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_driver_pool.h	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_driver_pool.h	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,212 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *           Copyright 2014 Big Switch Networks, Inc.
+ *           Copyright 2014 Accton Technology Corporation.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ *
+ *
+ ***********************************************************/
+#ifndef __VENDOR_DRIVER_POOL_H__
+#define __VENDOR_DRIVER_POOL_H__
+
+#include <onlp/onlp.h>
+#include <onlplib/file.h>
+#include <onlplib/i2c.h>
+#include <onlp/platformi/base.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <AIM/aim.h>
+#include "x86_64_stordis_bf2556x_1t_log.h"
+
+#define VENDOR_MAX_NAME_SIZE    20
+#define CPLD_DEV 1
+#define BMC_DEV 2
+
+typedef struct
+{
+	char *dev_name;
+    char *bus_drv_name;
+    char *dev_drv_name;
+	int bus;
+	uint8_t addr;
+    int id;
+}vendor_dev_t;
+
+typedef struct
+{
+    int type; /* 2 -> CPLD; 1 -> MUX; 0 -> invalid */
+    int bus;
+	uint8_t addr;
+    uint8_t offset; /* FOR CPLD & MUX */
+    uint8_t value;  /* FOR CPLD & MUX */
+    uint8_t mask;   /* FOR CPLD */
+    uint8_t match;  /* FOR CPLD */
+}vendor_dev_oc_t;
+
+typedef struct
+{
+    int type; /* 2 -> BMC; 1 -> CPLD; 0 -> invalid */
+    int bus;
+	uint8_t addr; /* DEVICE_TYPE + UNIT */
+    uint8_t offset;
+    uint8_t mask;
+    uint8_t match;
+}vendor_dev_io_pin_t;
+
+typedef struct
+{
+    int bus;
+	uint8_t addr;
+    uint8_t offset;
+    uint8_t mask;
+    uint8_t match;
+    onlp_led_mode_t mode;
+}vendor_dev_led_pin_t;
+
+typedef enum
+{
+    VENDOR_TEMPERATURE = 0,
+    VENDOR_FAN = 1,
+    VENDOR_PSU = 3,
+    VENDOR_FAN_PRESENT = VENDOR_FAN,
+    VENDOR_PSU_PRESENT = VENDOR_PSU,
+}vendor_bmc_device_type_t;
+
+typedef struct
+{
+    char name[VENDOR_MAX_NAME_SIZE];
+    void *dev_driver;
+}vendor_driver_t;
+
+typedef struct
+{
+    void *node;          
+    vendor_driver_t *driver_hdl;  
+}vendor_driver_node_t;
+
+typedef struct 
+{
+    int (*readb)        (int bus, uint8_t addr, uint16_t offset);
+    int (*writeb)       (int bus, uint8_t addr, uint16_t offset, uint8_t byte);
+    int (*readw)        (int bus, uint8_t addr, uint16_t offset);
+    int (*writew)       (int bus, uint8_t addr, uint16_t offset, uint16_t word);
+    int (*block_read)   (int bus, uint8_t addr, uint16_t offset, int size, uint8_t* rdata);
+}i2c_bus_driver_t;
+
+typedef struct 
+{
+    int (*get)(int bus, char *cmd, char *filter, char *data, uint32_t dlen);
+    int (*set)(int bus, char *cmd, char *filter);
+}ipmi_bus_driver_t;
+
+
+typedef struct 
+{
+    int (*present_get)(void *busDrvPtr, int bus, uint8_t addr, uint8_t offset, uint8_t *present);
+}present_get_driver_t;
+
+/* ONLY I2C */
+typedef struct
+{
+    int (*readb)    (void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint16_t len, uint8_t *buf);
+    int (*writeb)   (void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint16_t len, uint8_t *buf);
+    int (*load)     (void *busDrvPtr, int bus, uint8_t addr, uint8_t *buf);   
+}eeprom_dev_driver_t;
+
+/* ONLY I2C */
+typedef struct
+{
+    int (*readb)    (void *busDrvPtr, int bus, uint8_t addr, uint8_t offset, uint8_t *value);
+    int (*writeb)   (void *busDrvPtr, int bus, uint8_t addr, uint8_t offset, uint8_t value);
+}cpld_dev_driver_t;
+
+typedef struct
+{
+    int (*rpm_get)  (void *busDrvPtr, int bus, uint8_t addr, int id, int *rpm);
+    int (*rpm_set)  (void *busDrvPtr, int bus, uint8_t addr, int id, int rpm);
+}fan_dev_driver_t;
+
+typedef enum
+{
+    VENDOR_THERMAL_LOW_THRESHOLD,
+    VENDOR_THERMAL_HIGH_THRESHOLD,
+}vendor_thermal_threshold_e;
+
+typedef struct
+{
+    int (*temp_get)  (void *busDrvPtr, int bus, uint8_t addr, int id, int *temperature);
+    int (*limit_get) (void *busDrvPtr, int bus, uint8_t addr, int id, int type, int *temperature);
+    int (*limit_set) (void *busDrvPtr, int bus, uint8_t addr, int id, int type, int temperature);
+}thermal_dev_driver_t;
+
+typedef struct
+{
+    int (*model_get)   (void *busDrvPtr, int bus, uint8_t addr, char *model);
+    int (*serial_get)  (void *busDrvPtr, int bus, uint8_t addr, char *serial);
+    int (*volt_get)    (void *busDrvPtr, int bus, uint8_t addr, int *volt);
+    int (*amp_get)     (void *busDrvPtr, int bus, uint8_t addr, int *amp);
+    int (*watt_get)    (void *busDrvPtr, int bus, uint8_t addr, int *watt);
+}psu_dev_driver_t;
+
+typedef enum
+{
+    SFP_CONTROL_RESET,
+    SFP_CONTROL_RESET_STATE,
+    SFP_CONTROL_RX_LOS,
+    SFP_CONTROL_TX_FAULT,
+    SFP_CONTROL_TX_DISABLE,
+    SFP_CONTROL_TX_DISABLE_CHANNEL,
+    SFP_CONTROL_LP_MODE,
+    SFP_CONTROL_POWER_OVERRIDE,
+    SFP_CONTROL_TEMPERATURE,
+    SFP_CONTROL_VOLTAGE,
+    SFP_CONTROL_TX_BIAS,
+    SFP_CONTROL_RX_POWER,
+    SFP_CONTROL_TX_POWER,
+    SFP_CONTROL_LAST = SFP_CONTROL_TX_POWER,
+    SFP_CONTROL_COUNT,
+    SFP_CONTROL_INVALID = -1,
+}vendor_sfp_control_t;
+
+/* ONLY I2C */
+typedef struct
+{
+    int (*eeprom_load)          (void *busDrvPtr, int bus, uint8_t addr, uint8_t *data);
+    int (*eeprom_readb)         (void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint8_t *data);
+    int (*eeprom_writeb)        (void *busDrvPtr, int bus, uint8_t addr, uint16_t offset, uint8_t data);
+    int (*control_is_support)   (int control, uint8_t *is_support);
+    int (*control_get)          (void *busDrvPtr, int bus, uint8_t addr, int control, int *status);
+    int (*control_set)          (void *busDrvPtr, int bus, uint8_t addr, int control, int status);
+}sfp_dev_driver_t;    
+
+int vendor_find_cpld_idx(uint8_t addr);
+int vendor_system_call_get(char *cmd, char *data);
+int vendor_system_call_set(char *cmd);
+int vendor_driver_init();
+void *vendor_find_driver_by_name(const char *driver_name);
+int vendor_dev_do_oc(vendor_dev_oc_t *dev_oc);
+int vendor_get_present_status(vendor_dev_io_pin_t *present_info, int *present);
+int vendor_find_copper_by_name(const char *dev_name);
+
+#endif /* __VENDOR_DRIVER_POOL_H__ */
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_i2c_device_list.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_i2c_device_list.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_i2c_device_list.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_i2c_device_list.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,1502 @@
+#include "vendor_driver_pool.h"
+
+int thermal_list_size = 4;
+int fan_list_size = 8;
+int sysled_list_size = 0;
+int psu_list_size = 2;
+int sfp_list_size = 56;
+int sfp_start_port = 0;
+int sfp_num_of_sfp = 48;
+int eeprom_list_size = 1;
+int cpld_list_size = 3;
+
+vendor_dev_t thermal_dev_list[] =
+{
+	{"thermal-0", "IPMI", "BMC_TMP", 0x00, 0x00, 0x00},
+	{"thermal-1", "IPMI", "BMC_TMP", 0x00, 0x01, 0x00},
+	{"thermal-2", "IPMI", "BMC_TMP", 0x00, 0x02, 0x00},
+	{"thermal-3", "IPMI", "BMC_TMP", 0x00, 0x03, 0x00},
+};
+
+vendor_dev_t fan_dev_list[] =
+{
+	{"fan-0", "IPMI", "BMC_FAN", 0x00, 0x40, 0x00},
+	{"fan-1", "IPMI", "BMC_FAN", 0x00, 0x41, 0x00},
+	{"fan-2", "IPMI", "BMC_FAN", 0x00, 0x42, 0x00},
+	{"fan-3", "IPMI", "BMC_FAN", 0x00, 0x43, 0x00},
+	{"fan-4", "IPMI", "BMC_FAN", 0x00, 0x44, 0x00},
+	{"fan-5", "IPMI", "BMC_FAN", 0x00, 0x45, 0x00},
+	{"fan-6", "IPMI", "BMC_FAN", 0x00, 0x46, 0x00},
+	{"fan-7", "IPMI", "BMC_FAN", 0x00, 0x47, 0x00},
+};
+
+vendor_dev_t sysled_dev_list[] =
+{
+};
+
+vendor_dev_t psu_dev_list[] =
+{
+	{"psu-0", "IPMI", "BMC_PSU", 0x00, 0xc0, 0x00},
+	{"psu-1", "IPMI", "BMC_PSU", 0x00, 0xc1, 0x00},
+};
+
+vendor_dev_t sfp_dev_list[] =
+{
+	{"eeprom-port-0", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-1", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-2", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-3", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-4", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-5", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-6", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-7", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-8", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-9", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-10", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-11", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-12", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-13", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-14", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-15", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-16", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-17", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-18", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-19", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-20", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-21", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-22", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-23", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-24", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-25", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-26", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-27", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-28", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-29", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-30", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-31", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-32", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-33", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-34", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-35", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-36", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-37", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-38", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-39", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-40", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-41", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-42", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-43", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-44", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-45", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-46", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-47", "I2C", "SFF8472", 0x02, 0x50, 0x00},
+	{"eeprom-port-48", "I2C", "SFF8436", 0x02, 0x50, 0x00},
+	{"eeprom-port-49", "I2C", "SFF8436", 0x02, 0x50, 0x00},
+	{"eeprom-port-50", "I2C", "SFF8436", 0x02, 0x50, 0x00},
+	{"eeprom-port-51", "I2C", "SFF8436", 0x02, 0x50, 0x00},
+	{"eeprom-port-52", "I2C", "SFF8436", 0x02, 0x50, 0x00},
+	{"eeprom-port-53", "I2C", "SFF8436", 0x02, 0x50, 0x00},
+	{"eeprom-port-54", "I2C", "SFF8436", 0x02, 0x50, 0x00},
+	{"eeprom-port-55", "I2C", "SFF8436", 0x02, 0x50, 0x00},
+};
+
+vendor_dev_t eeprom_dev_list[] =
+{
+	{"baseboard-eeprom", "I2C", "EEPROM", 0x02, 0x56, 0x02},
+};
+
+vendor_dev_t cpld_dev_list[] =
+{
+	{"CPLD-1", "I2C", "CPLD", 0x02, 0x30, 0x00},
+	{"CPLD-2", "I2C", "CPLD", 0x02, 0x32, 0x00},
+	{"CPLD-3", "I2C", "CPLD", 0x02, 0xb2, 0x00},
+};
+
+vendor_dev_oc_t *thermal_o_list[] =
+{
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+vendor_dev_oc_t *thermal_c_list[] =
+{
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+vendor_dev_oc_t *fan_o_list[] =
+{
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+vendor_dev_oc_t *fan_c_list[] =
+{
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+vendor_dev_oc_t *psu_o_list[] =
+{
+	NULL,
+	NULL,
+};
+
+vendor_dev_oc_t *psu_c_list[] =
+{
+	NULL,
+	NULL,
+};
+
+static vendor_dev_oc_t sfp_1_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x01, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_1_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_2_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x02, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_2_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_3_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x04, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_3_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_4_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x08, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_4_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_5_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x10, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_5_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_6_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x20, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_6_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_7_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x40, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_7_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_8_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x80, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_8_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x01, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_9_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x01, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_9_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_10_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x02, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_10_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_11_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x04, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_11_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_12_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x08, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_12_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_13_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x10, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_13_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_14_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x20, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_14_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_15_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x40, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_15_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_16_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x80, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_16_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x02, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_17_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x01, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_17_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_18_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x02, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_18_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_19_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x04, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_19_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_20_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x08, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_20_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_21_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x10, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_21_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_22_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x20, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_22_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_23_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x40, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_23_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_24_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x80, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_24_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x04, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_25_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x01, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_25_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_26_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x02, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_26_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_27_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x04, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_27_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_28_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x08, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_28_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_29_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x10, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_29_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_30_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x20, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_30_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_31_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x40, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_31_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_32_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x80, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_32_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x08, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_33_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x01, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_33_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_34_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x02, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_34_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_35_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x04, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_35_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_36_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x08, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_36_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_37_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x10, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_37_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_38_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x20, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_38_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_39_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x40, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_39_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_40_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x80, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_40_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x10, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_41_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x01, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_41_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_42_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x02, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_42_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_43_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x04, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_43_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_44_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x08, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_44_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_45_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x10, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_45_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_46_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x20, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_46_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_47_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x40, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_47_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_48_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x80, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_48_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x20, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_49_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x01, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_49_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_50_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x02, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_50_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_51_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x04, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_51_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_52_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x08, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_52_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_53_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x10, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_53_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_54_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x20, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_54_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_55_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x40, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_55_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_56_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x80, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t sfp_56_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+	{0x01, 0x02, 0x72, 0x00, 0x00, 0x00, 0x00},
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+vendor_dev_oc_t *sfp_o_list[] =
+{
+	sfp_1_o,
+	sfp_2_o,
+	sfp_3_o,
+	sfp_4_o,
+	sfp_5_o,
+	sfp_6_o,
+	sfp_7_o,
+	sfp_8_o,
+	sfp_9_o,
+	sfp_10_o,
+	sfp_11_o,
+	sfp_12_o,
+	sfp_13_o,
+	sfp_14_o,
+	sfp_15_o,
+	sfp_16_o,
+	sfp_17_o,
+	sfp_18_o,
+	sfp_19_o,
+	sfp_20_o,
+	sfp_21_o,
+	sfp_22_o,
+	sfp_23_o,
+	sfp_24_o,
+	sfp_25_o,
+	sfp_26_o,
+	sfp_27_o,
+	sfp_28_o,
+	sfp_29_o,
+	sfp_30_o,
+	sfp_31_o,
+	sfp_32_o,
+	sfp_33_o,
+	sfp_34_o,
+	sfp_35_o,
+	sfp_36_o,
+	sfp_37_o,
+	sfp_38_o,
+	sfp_39_o,
+	sfp_40_o,
+	sfp_41_o,
+	sfp_42_o,
+	sfp_43_o,
+	sfp_44_o,
+	sfp_45_o,
+	sfp_46_o,
+	sfp_47_o,
+	sfp_48_o,
+	sfp_49_o,
+	sfp_50_o,
+	sfp_51_o,
+	sfp_52_o,
+	sfp_53_o,
+	sfp_54_o,
+	sfp_55_o,
+	sfp_56_o,
+};
+
+vendor_dev_oc_t *sfp_c_list[] =
+{
+	sfp_1_c,
+	sfp_2_c,
+	sfp_3_c,
+	sfp_4_c,
+	sfp_5_c,
+	sfp_6_c,
+	sfp_7_c,
+	sfp_8_c,
+	sfp_9_c,
+	sfp_10_c,
+	sfp_11_c,
+	sfp_12_c,
+	sfp_13_c,
+	sfp_14_c,
+	sfp_15_c,
+	sfp_16_c,
+	sfp_17_c,
+	sfp_18_c,
+	sfp_19_c,
+	sfp_20_c,
+	sfp_21_c,
+	sfp_22_c,
+	sfp_23_c,
+	sfp_24_c,
+	sfp_25_c,
+	sfp_26_c,
+	sfp_27_c,
+	sfp_28_c,
+	sfp_29_c,
+	sfp_30_c,
+	sfp_31_c,
+	sfp_32_c,
+	sfp_33_c,
+	sfp_34_c,
+	sfp_35_c,
+	sfp_36_c,
+	sfp_37_c,
+	sfp_38_c,
+	sfp_39_c,
+	sfp_40_c,
+	sfp_41_c,
+	sfp_42_c,
+	sfp_43_c,
+	sfp_44_c,
+	sfp_45_c,
+	sfp_46_c,
+	sfp_47_c,
+	sfp_48_c,
+	sfp_49_c,
+	sfp_50_c,
+	sfp_51_c,
+	sfp_52_c,
+	sfp_53_c,
+	sfp_54_c,
+	sfp_55_c,
+	sfp_56_c,
+};
+
+vendor_dev_oc_t *eeprom_o_list[] =
+{
+	NULL,
+};
+
+vendor_dev_oc_t *eeprom_c_list[] =
+{
+	NULL,
+};
+
+static vendor_dev_oc_t cpld_1_o[] =
+{
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t cpld_1_c[] =
+{
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t cpld_2_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x80, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t cpld_2_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t cpld_3_o[] =
+{
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x01},
+	{0x01, 0x02, 0x71, 0x00, 0x40, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+static vendor_dev_oc_t cpld_3_c[] =
+{
+	{0x01, 0x02, 0x71, 0x00, 0x00, 0x00, 0x00},
+    {0x02, 0x02, 0x30, 0x0f, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+vendor_dev_oc_t *cpld_o_list[] =
+{
+	cpld_1_o,
+	cpld_2_o,
+	cpld_3_o,
+};
+
+vendor_dev_oc_t *cpld_c_list[] =
+{
+	cpld_1_c,
+	cpld_2_c,
+	cpld_3_c,
+};
+
+vendor_dev_io_pin_t fan_present_list[] =
+{
+	{ 0x02, 0x00, 0x40, 0x00, 0x00, 0x00},
+	{ 0x02, 0x00, 0x41, 0x00, 0x00, 0x00},
+	{ 0x02, 0x00, 0x42, 0x00, 0x00, 0x00},
+	{ 0x02, 0x00, 0x43, 0x00, 0x00, 0x00},
+	{ 0x02, 0x00, 0x44, 0x00, 0x00, 0x00},
+	{ 0x02, 0x00, 0x45, 0x00, 0x00, 0x00},
+	{ 0x02, 0x00, 0x46, 0x00, 0x00, 0x00},
+	{ 0x02, 0x00, 0x47, 0x00, 0x00, 0x00},
+};
+
+vendor_dev_led_pin_t *sysled_color_list[] =
+{
+	NULL,
+};
+
+vendor_dev_io_pin_t psu_present_list[] =
+{
+	{ 0x02, 0x00, 0xc0, 0x00, 0x00, 0x00},
+	{ 0x02, 0x00, 0xc1, 0x00, 0x00, 0x00},
+};
+
+vendor_dev_io_pin_t sfp_present_list[] =
+{
+	{ 0x01, 0x02, 0x32, 0x01, 0x80, 0x00},
+	{ 0x01, 0x02, 0x32, 0x01, 0x40, 0x00},
+	{ 0x01, 0x02, 0x32, 0x01, 0x20, 0x00},
+	{ 0x01, 0x02, 0x32, 0x01, 0x10, 0x00},
+	{ 0x01, 0x02, 0x32, 0x01, 0x08, 0x00},
+	{ 0x01, 0x02, 0x32, 0x01, 0x04, 0x00},
+	{ 0x01, 0x02, 0x32, 0x01, 0x02, 0x00},
+	{ 0x01, 0x02, 0x32, 0x01, 0x01, 0x00},
+	{ 0x01, 0x02, 0x32, 0x02, 0x80, 0x00},
+	{ 0x01, 0x02, 0x32, 0x02, 0x40, 0x00},
+	{ 0x01, 0x02, 0x32, 0x02, 0x20, 0x00},
+	{ 0x01, 0x02, 0x32, 0x02, 0x10, 0x00},
+	{ 0x01, 0x02, 0x32, 0x02, 0x08, 0x00},
+	{ 0x01, 0x02, 0x32, 0x02, 0x04, 0x00},
+	{ 0x01, 0x02, 0x32, 0x02, 0x02, 0x00},
+	{ 0x01, 0x02, 0x32, 0x02, 0x01, 0x00},
+	{ 0x01, 0x02, 0x32, 0x03, 0x80, 0x00},
+	{ 0x01, 0x02, 0x32, 0x03, 0x40, 0x00},
+	{ 0x01, 0x02, 0x32, 0x03, 0x20, 0x00},
+	{ 0x01, 0x02, 0x32, 0x03, 0x10, 0x00},
+	{ 0x01, 0x02, 0x32, 0x03, 0x08, 0x00},
+	{ 0x01, 0x02, 0x32, 0x03, 0x04, 0x00},
+	{ 0x01, 0x02, 0x32, 0x03, 0x02, 0x00},
+	{ 0x01, 0x02, 0x32, 0x03, 0x01, 0x00},
+	{ 0x01, 0x02, 0x32, 0x04, 0x80, 0x00},
+	{ 0x01, 0x02, 0x32, 0x04, 0x40, 0x00},
+	{ 0x01, 0x02, 0x32, 0x04, 0x20, 0x00},
+	{ 0x01, 0x02, 0x32, 0x04, 0x10, 0x00},
+	{ 0x01, 0x02, 0x32, 0x04, 0x08, 0x00},
+	{ 0x01, 0x02, 0x32, 0x04, 0x04, 0x00},
+	{ 0x01, 0x02, 0x32, 0x04, 0x02, 0x00},
+	{ 0x01, 0x02, 0x32, 0x04, 0x01, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x01, 0x80, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x01, 0x40, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x01, 0x20, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x01, 0x10, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x01, 0x08, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x01, 0x04, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x01, 0x02, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x01, 0x01, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x02, 0x80, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x02, 0x40, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x02, 0x20, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x02, 0x10, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x02, 0x08, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x02, 0x04, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x02, 0x02, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x02, 0x01, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x03, 0x80, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x03, 0x40, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x03, 0x20, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x03, 0x10, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x03, 0x08, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x03, 0x04, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x03, 0x02, 0x00},
+	{ 0x01, 0x02, 0xb2, 0x03, 0x01, 0x00},
+};
+
+vendor_dev_io_pin_t sfp_lpmode_list[] =
+{
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
+
+vendor_dev_io_pin_t sfp_reset_list[] =
+{
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+};
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_i2c_device_list.h ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_i2c_device_list.h
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_i2c_device_list.h	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/vendor_i2c_device_list.h	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,81 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *           Copyright 2014 Big Switch Networks, Inc.
+ *           Copyright 2014 Accton Technology Corporation.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ *
+ *
+ ***********************************************************/
+#ifndef __VENDOR_DEVICE_LIST_H__
+#define __VENDOR_DEVICE_LIST_H__
+
+#include <onlp/onlp.h>
+#include <onlplib/file.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <AIM/aim.h>
+#include "vendor_driver_pool.h"
+
+extern int sysled_list_size;
+extern vendor_dev_t sysled_dev_list[];
+extern vendor_dev_led_pin_t *sysled_color_list[];
+
+extern int cpld_list_size;
+extern vendor_dev_t cpld_dev_list[];
+extern vendor_dev_oc_t *cpld_o_list[];
+extern vendor_dev_oc_t *cpld_c_list[];
+
+extern int eeprom_list_size;
+extern vendor_dev_t eeprom_dev_list[];
+extern vendor_dev_oc_t *eeprom_o_list[];
+extern vendor_dev_oc_t *eeprom_c_list[];
+
+extern int thermal_list_size;
+extern vendor_dev_t thermal_dev_list[];
+extern vendor_dev_oc_t *thermal_o_list[];
+extern vendor_dev_oc_t *thermal_c_list[];
+
+extern int fan_list_size;
+extern vendor_dev_t fan_dev_list[];
+extern vendor_dev_io_pin_t fan_present_list[];
+extern vendor_dev_oc_t *fan_o_list[];
+extern vendor_dev_oc_t *fan_c_list[];
+
+extern int psu_list_size;
+extern vendor_dev_t psu_dev_list[];
+extern vendor_dev_io_pin_t psu_present_list[];
+extern vendor_dev_oc_t *psu_o_list[];
+extern vendor_dev_oc_t *psu_c_list[];
+
+extern int sfp_list_size;
+extern int sfp_start_port;
+extern int sfp_num_of_sfp;
+extern vendor_dev_t sfp_dev_list[];
+extern vendor_dev_io_pin_t sfp_present_list[];
+extern vendor_dev_io_pin_t sfp_lpmode_list[];
+extern vendor_dev_io_pin_t sfp_reset_list[];
+extern vendor_dev_oc_t *sfp_o_list[];
+extern vendor_dev_oc_t *sfp_c_list[];
+
+#endif /* __VENDOR_DEVICE_LIST_H__ */
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_config.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_config.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_config.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_config.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,92 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+
+
+#include <x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h>
+
+/* <auto.start.cdefs(X86_64_STORDIS_BF2556X_1T_CONFIG_HEADER).source> */
+#define __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(_x) #_x
+#define __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(_x) __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(_x)
+x86_64_stordis_bf2556x_1t_config_settings_t x86_64_stordis_bf2556x_1t_config_settings[] =
+{
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_LOGGING
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_LOGGING), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_LOGGING) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_LOGGING(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_STDLIB(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_DEFAULT_FAN_DIRECTION
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_DEFAULT_FAN_DIRECTION), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_DEFAULT_FAN_DIRECTION) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_DEFAULT_FAN_DIRECTION(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_SFP_COUNT
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_SFP_COUNT), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_SFP_COUNT) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_SFP_COUNT(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_STORDIS_BF2556X_1T_CONFIG_FAN_RPM_MAX
+    { __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME(X86_64_STORDIS_BF2556X_1T_CONFIG_FAN_RPM_MAX), __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE(X86_64_STORDIS_BF2556X_1T_CONFIG_FAN_RPM_MAX) },
+#else
+{ X86_64_STORDIS_BF2556X_1T_CONFIG_FAN_RPM_MAX(__x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+    { NULL, NULL }
+};
+#undef __x86_64_stordis_bf2556x_1t_config_STRINGIFY_VALUE
+#undef __x86_64_stordis_bf2556x_1t_config_STRINGIFY_NAME
+
+const char*
+x86_64_stordis_bf2556x_1t_config_lookup(const char* setting)
+{
+    int i;
+    for(i = 0; x86_64_stordis_bf2556x_1t_config_settings[i].name; i++) {
+        if(!strcmp(x86_64_stordis_bf2556x_1t_config_settings[i].name, setting)) {
+            return x86_64_stordis_bf2556x_1t_config_settings[i].value;
+        }
+    }
+    return NULL;
+}
+
+int
+x86_64_stordis_bf2556x_1t_config_show(struct aim_pvs_s* pvs)
+{
+    int i;
+    for(i = 0; x86_64_stordis_bf2556x_1t_config_settings[i].name; i++) {
+        aim_printf(pvs, "%s = %s\n", x86_64_stordis_bf2556x_1t_config_settings[i].name, x86_64_stordis_bf2556x_1t_config_settings[i].value);
+    }
+    return i;
+}
+
+/* <auto.end.cdefs(X86_64_STORDIS_BF2556X_1T_CONFIG_HEADER).source> */
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_enums.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_enums.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_enums.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_enums.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,12 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+
+
+#include <x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h>
+
+/* <--auto.start.enum(ALL).source> */
+/* <auto.end.enum(ALL).source> */
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_int.h ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_int.h
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_int.h	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_int.h	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,13 @@
+/**************************************************************************//**
+ *
+ * x86_64_stordis_bf2556x_1t Internal Header
+ *
+ *****************************************************************************/
+
+#ifndef __X86_64_STORDIS_BF2556X_1T_INT_H__
+#define __X86_64_STORDIS_BF2556X_1T_INT_H__
+
+#include <x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h>
+
+
+#endif /* __X86_64_STORDIS_BF2556X_1T_INT_H__ */
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_log.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_log.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_log.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_log.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,21 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+
+
+#include <x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h>
+
+#include "x86_64_stordis_bf2556x_1t_log.h"
+/*
+ * x86_64_stordis_bf2556x_1t log struct.
+ */
+AIM_LOG_STRUCT_DEFINE
+(
+    X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_OPTIONS_DEFAULT,
+    X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_BITS_DEFAULT,
+    NULL, /* Custom log map */
+    X86_64_STORDIS_BF2556X_1T_CONFIG_LOG_CUSTOM_BITS_DEFAULT
+);
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_log.h ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_log.h
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_log.h	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_log.h	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,14 @@
+/**************************************************************************//**
+ *
+ * 
+ *
+ *****************************************************************************/
+
+
+#ifndef __X86_64_STORDIS_BF2556X_1T_LOG_H__
+#define __X86_64_STORDIS_BF2556X_1T_LOG_H__
+
+#define AIM_LOG_MODULE_NAME x86_64_stordis_bf2556x_1t
+#include <AIM/aim_log.h>
+
+#endif /* __X86_64_STORDIS_BF2556X_1T_LOG_H__ */
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_module.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_module.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_module.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_module.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,26 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+
+
+#include <x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h>
+
+#include "x86_64_stordis_bf2556x_1t_log.h"
+
+static int
+datatypes_init__(void)
+{
+#define x86_64_STORDIS_BF2556X_1T_ENUMERATION_ENTRY(_enum_name, _desc)     AIM_DATATYPE_MAP_REGISTER(_enum_name, _enum_name##_map, _desc,                               AIM_LOG_INTERNAL);
+#include <x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t.x>
+    return 0;
+}
+
+void __x86_64_stordis_bf2556x_1t_module_init__(void)
+{
+    AIM_LOG_STRUCT_REGISTER();
+    datatypes_init__();
+}
+
+int __onlp_platform_version__ = 1;
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_ucli.c ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_ucli.c
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_ucli.c	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/module/src/x86_64_stordis_bf2556x_1t_ucli.c	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,64 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+
+
+#include <x86_64_stordis_bf2556x_1t/x86_64_stordis_bf2556x_1t_config.h>
+
+#if X86_64_STORDIS_BF2556X_1T_CONFIG_INCLUDE_UCLI == 1
+
+#include <uCli/ucli.h>
+#include <uCli/ucli_argparse.h>
+#include <uCli/ucli_handler_macros.h>
+
+static ucli_status_t
+x86_64_stordis_bf2556x_1t_ucli_ucli__config__(ucli_context_t* uc)
+{
+    UCLI_HANDLER_MACRO_MODULE_CONFIG(x86_64_stordis_bf2556x_1t)
+}
+
+/* <auto.ucli.handlers.start> */
+/******************************************************************************
+ *
+ * These handler table(s) were autogenerated from the symbols in this
+ * source file.
+ *
+ *****************************************************************************/
+static ucli_command_handler_f x86_64_stordis_bf2556x_1t_ucli_ucli_handlers__[] =
+{
+    x86_64_stordis_bf2556x_1t_ucli_ucli__config__,
+    NULL
+};
+/******************************************************************************/
+/* <auto.ucli.handlers.end> */
+
+static ucli_module_t
+x86_64_stordis_bf2556x_1t_ucli_module__ =
+{
+    "x86_64_stordis_bf2556x_1t_ucli",
+    NULL,
+    x86_64_stordis_bf2556x_1t_ucli_ucli_handlers__,
+    NULL,
+    NULL,
+};
+
+ucli_node_t*
+x86_64_stordis_bf2556x_1t_ucli_node_create(void)
+{
+    ucli_node_t* n;
+    ucli_module_init(&x86_64_stordis_bf2556x_1t_ucli_module__);
+    n = ucli_node_create("x86_64_stordis_bf2556x_1t", NULL, &x86_64_stordis_bf2556x_1t_ucli_module__);
+    ucli_node_subnode_add(n, ucli_module_log_node_create("x86_64_stordis_bf2556x_1t"));
+    return n;
+}
+
+#else
+void*
+x86_64_stordis_bf2556x_1t_ucli_node_create(void)
+{
+    return NULL;
+}
+#endif
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/.module ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/.module
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/.module	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/builds/x86_64_stordis_bf2556x_1t/.module	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+name: x86_64_stordis_bf2556x_1t
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/PKG.yml ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/PKG.yml
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/PKG.yml	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/onlp/PKG.yml	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+!include $ONL_TEMPLATES/onlp-platform-any.yml PLATFORM=x86-64-stordis-bf2556x-1t ARCH=amd64 TOOLCHAIN=x86_64-linux-gnu
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/Makefile	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/Makefile	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/PKG.yml ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/PKG.yml
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/PKG.yml	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/PKG.yml	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,2 @@
+!include $ONL_TEMPLATES/platform-config-platform.yml ARCH=amd64 VENDOR=stordis BASENAME=x86-64-stordis-bf2556x-1t REVISION=r0
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/src/lib/x86-64-stordis-bf2556x-1t-r0.yml ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/src/lib/x86-64-stordis-bf2556x-1t-r0.yml
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/src/lib/x86-64-stordis-bf2556x-1t-r0.yml	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/src/lib/x86-64-stordis-bf2556x-1t-r0.yml	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,31 @@
+---
+
+######################################################################
+#
+# platform-config for STORDIS BF2556X-1T
+######################################################################
+
+x86-64-stordis-bf2556x-1t-r0:
+
+  grub:
+
+    serial: >-
+      --port=0x3f8
+      --speed=115200
+      --word=8
+      --parity=no
+      --stop=1
+
+    kernel:
+      <<: *kernel-3-16
+
+    args: >-
+      nopat
+      console=ttyS0,115200n8
+
+  network:
+
+    interfaces:
+      ma1:
+        name: eth2
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/src/python/x86_64_stordis_bf2556x_1t_r0/__init__.py ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/src/python/x86_64_stordis_bf2556x_1t_r0/__init__.py
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/src/python/x86_64_stordis_bf2556x_1t_r0/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/bf2556x-1t/platform-config/r0/src/python/x86_64_stordis_bf2556x_1t_r0/__init__.py	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1,13 @@
+from onl.platform.base import *
+from onl.platform.stordis import *
+
+class OnlPlatform_x86_64_stordis_bf2556x_1t_r0(OnlPlatformStordis,
+                                         OnlPlatformPortConfig_48x25_8x100):
+    PLATFORM='x86-64-stordis-bf2556x-1t-r0'
+    MODEL="BF2556X-1T"
+    SYS_OBJECT_ID=".25560.1"
+    
+    def baseconfig(self):
+        
+        return True
+
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/Makefile	2020-06-19 08:07:40.607556160 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/modules/Makefile ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/modules/Makefile
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/modules/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/modules/Makefile	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff '--exclude=.git' -aruN ./OpenNetworkLinux/packages/platforms/stordis/x86-64/modules/PKG.yml ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/modules/PKG.yml
--- ./OpenNetworkLinux/packages/platforms/stordis/x86-64/modules/PKG.yml	1970-01-01 01:00:00.000000000 +0100
+++ ../stordis_onlpv2/OpenNetworkLinux/packages/platforms/stordis/x86-64/modules/PKG.yml	2020-06-19 08:07:40.611556150 +0200
@@ -0,0 +1 @@
+!include $ONL_TEMPLATES/no-arch-vendor-modules.yml ARCH=amd64 VENDOR=stordis
diff '--exclude=.git' -aruN ./OpenNetworkLinux/setup.env ../stordis_onlpv2/OpenNetworkLinux/setup.env
--- ./OpenNetworkLinux/setup.env	2020-06-19 08:08:44.275416640 +0200
+++ ../stordis_onlpv2/OpenNetworkLinux/setup.env	2020-06-19 08:07:40.607556160 +0200
@@ -52,10 +52,9 @@
 # submodule post update scripts.
 export ONL_SUBMODULE_UPDATED_SCRIPTS="$ONL/tools/scripts/submodule-updated.sh"
 
-export ONLPM_OPTION_PLATFORM_WHITELIST="\
-x86-64-accton-as7712-32x-r0
-x86-64-accton-as5812-54x-r0
-x86-64-inventec-d5254-r0
-x86-64-accton-wedge100bf-32x-r0
-x86-64-delta-ag9032v1-r0
-"
+# Used by OpenNetworkLinux/builds/{arch}/rootfs/builds/Makefile
+export PLATFORM_LIST=x86-64-stordis-bf2556x-1t-r0
+# Used by OpenNetworkLinux/packages/base/any/initrds/loader/builds/Makefile
+export PLATFORMS=x86-64-stordis-bf2556x-1t-r0
+# Used by OpenNetworkLinux/tools/onlpm.py
+export ONLPM_OPTION_PLATFORM_WHITELIST="x86-64-stordis-bf2556x-1t-r0"
